/*
 *  hddm-cpp :	tool that reads in a HDDM document (Hall D Data Model)
 *		and writes a c++ class library that expresses the model
 *		in c++ classes.  It also generates input/output methods
 *		for serializing/deserializing these classes in a form
 *		suitable for passing over a network or storing on disk.
 *
 *  author: richard.t.jones at uconn.edu
 *  version: January 25, 2006 - original release.
 *           January 13, 2012 - added support for compression through
 *                              the xstream zip and bzip2 facilities.
 *           June 4, 2016     - added reposition support for random
 *                              access to hddm streams, including
 *                              compressed streams.
 *
 *
 *  Programmer's Notes:
 *  -------------------
 * 1. The HDDM specification describes data files using xml.  For
 *    information about the contents and structure of HDDM documents
 *    see the web page that describes the data model.
 *
 * 2. Access by hddm-cpp to the xml source is through the industry-
 *    standard Document Object Model (DOM) interface.
 *
 * 3. The code has been tested with the xerces-c DOM implementation from
 *    Apache, and is intended to be used with the xerces-c library.
 *
 * 4. Output is sent to <filename>.hpp and <filename>.cpp where <filename>
 *    is by default "hddm_X" and can be changed with the -o option, where
 *    X is the user-defined HDDM class string defined in the HDDM tag.
 *
 * 5. As a by-product of using the DOM parser to access the xml source,
 *    hddm-cpp verifies the source for well-formedness.  Therefore it may
 *    also be used to check the xml data model document.
 *
 *
 *  Implementation Notes:
 *  ---------------------
 * 1. The binary stream consists of the hddm data model in the form
 *    of a well-formed xml header, followed by binary data.
 *
 * 2. The binary data consist of a sequence of event records, which are
 *    repetitions of the basic data model in a serial representation.
 *
 * 3. Each element is output to the stream in the order it appears in
 *    the data model, prefixed by an exclusive byte count.
 *
 * 4. Any c++ application compiled with the hddm header file that is
 *    generated by hddm-cpp is able to read any hddm binary file that
 *    was written using the same hddm class, ie. the <HDDM class="x">
 *    document tags must be a non-colliding set (see matching rules).
 *
 * 5. The input/output features of the class library produced by hddm-cpp
 *    are implemented on top of the "xstream" binary i/o class by Claudio
 *    Valente which provides serialization/deserialization of binary data
 *    using network byte-ordering (RFC-1832), compression/decompression,
 *    and error checking capability used to make the hddm i/o facility
 *    flexible and robust.
 *
 * 6. The matching rules between the built-in data model and the data
 *    found in an arbitrary input file are as follows:
 *    a) The attribute list for any given tag must be identical in content
 *       and order wherever it appears, otherwise there is a collision.
 *    b) The content list for any given tag must be internally consistent
 *       within each model, but there are no requirements for agreement
 *       between the classes and the binary stream models.  Only the
 *       contents which appear in both models will be unpacked, however.
 */

#include "XString.hpp"
#include "XParsers.hpp"
#include <xercesc/util/XMLUri.hpp>

#include <particleType.h>
#include <errno.h>

#include <string>
#include <vector>
#include <map>
#include <fstream>

#define X(str) XString(str).unicode_str()
#define S(str) str.c_str()

using namespace xercesc;

XString classPrefix;

void usage()
{
   std::cerr
        << "\nUsage:\n"
        << "    hddm-cpp [-v | -o <filename>] {HDDM file}\n\n"
        << "Options:\n"
        <<  "    -v			validate only\n"
        <<  "    -o <filename>	write to <filename>.hpp, <filename>.cpp"
        << std::endl;
}

std::string guessType(const std::string &literal);
Particle_t lookupParticle(const std::string &name);

class XtString : public XString
{
/* XString class with a few extra methods for creating type
 * strings that are useful in creating class names
 */
 public:
   XtString() {};
   XtString(const char* s): XString(s) {};
   XtString(const XMLCh* p): XString(p) {};
   XtString(const std::string& s): XString(s) {};
   XtString(const XString& x): XString(x) {};
   XtString(const XtString& t): XString((XString&)t) {};
   ~XtString() {};

   XtString plural();
   XtString simpleType();
   XtString listType();
   XtString linkType();
};

class CodeBuilder
{
/* The methods in this class are used to write the c++ code
 * that implements the hddm class library.
 */
 public:
   std::ofstream hFile;
   std::ofstream cFile;

   CodeBuilder() {};
   ~CodeBuilder() {};

   void checkConsistency(DOMElement* el, DOMElement* elref);
   void writeClassdef(DOMElement* el);
   void writeClassimp(DOMElement* el);
   void constructDocument(DOMElement* el);
   void constructGroup(DOMElement* el);
   void constructIOstreams(DOMElement* el);
   void constructMethods(DOMElement* el);
   void constructStreamers(DOMElement* el);
   void writeStreamers(DOMElement* el);

 private:
   std::vector<DOMElement*> tagList;
   typedef std::vector<DOMNode*> parentList_t;
   typedef std::map<const XtString,parentList_t> parentTable_t;
   parentList_t parentList;
   parentTable_t parents;
   parentTable_t children;
   int element_in_list(XtString &name, parentList_t list);
};


int main(int argC, char* argV[])
{
   try
   {
      XMLPlatformUtils::Initialize();
   }
   catch (const XMLException* toCatch)
   {
      XtString msg(toCatch->getMessage());
      std::cerr
           << "hddm-cpp: Error during initialization! :\n"
           << msg << std::endl;
      return 1;
   }

   if (argC < 2)
   {
      usage();
      return 1;
   }
   else if ((argC == 2) && (strcmp(argV[1], "-?") == 0))
   {
      usage();
      return 2;
   }

   XtString xmlFile;
   XtString hFilename;
   bool verifyOnly = false;
   int argInd;
   for (argInd = 1; argInd < argC; argInd++)
   {
      if (argV[argInd][0] != '-')
      {
         break;
      }
      if (strcmp(argV[argInd],"-v") == 0)
      {
         verifyOnly = true;
      }
      else if (strcmp(argV[argInd],"-o") == 0)
      {
         hFilename = XtString(argV[++argInd]);
      }
      else
      {
         std::cerr
              << "Unknown option \'" << argV[argInd]
              << "\', ignoring it\n" << std::endl;
      }
   }

   if (argInd != argC - 1)
   {
      usage();
      return 1;
   }
   xmlFile = XtString(argV[argInd]);

#if defined OLD_STYLE_XERCES_PARSER
   DOMDocument* document = parseInputDocument(xmlFile.c_str(),false);
#else
   DOMDocument* document = buildDOMDocument(xmlFile.c_str(),false);
#endif
   if (document == 0)
   {
      std::cerr
           << "hddm-cpp : Error parsing HDDM document, "
           << "cannot continue" << std::endl;
      return 1;
   }

   DOMElement* rootEl = document->getDocumentElement();
   XtString rootS(rootEl->getTagName());
   if (rootS != "HDDM")
   {
      std::cerr
           << "hddm-cpp error: root element of input document is "
           << "\"" << rootS << "\", expected \"HDDM\""
           << std::endl;
      return 1;
   }

   XtString classS(rootEl->getAttribute(X("class")));
   classPrefix = classS;

   XtString hname;
   if (verifyOnly)
   {
      hname = "/dev/null";
   }
   else if (hFilename.size())
   {
      hname = hFilename + ".hpp";
   }
   else
   {
      hname = "hddm_" + classPrefix + ".hpp";
   }

   CodeBuilder builder;
   builder.hFile.open(hname.c_str());
   if (! builder.hFile.is_open())
   {
      std::cerr
           << "hddm-cpp error: unable to open output file "
           << hname << std::endl;
      return 1;
   }

   XtString cname;
   if (verifyOnly)
   {
      cname = "/dev/null";
   }
   else if (hFilename.size())
   {
      cname = hFilename + ".cpp";
   }
   else
   {
      cname = "hddm_" + classPrefix + ".cpp";
   }

   builder.cFile.open(cname.c_str());
   if (! builder.cFile.is_open())
   {
      std::cerr
           << "hddm-cpp error: unable to open output file "
           << cname << std::endl;
      return 1;
   }

   builder.hFile <<
   "/*\n"
   " * hddm_" << classPrefix << ".hpp - DO NOT EDIT THIS FILE\n"
   " *\n"
   " * This file was generated automatically by hddm-cpp from the file\n"
   << " * " << xmlFile << std::endl <<
   "\n"
   " * This header file defines the c++ classes that hold the data\n"
   " * described in the data model (from " << xmlFile << "). \n"
   " *\n"
   " * The hddm data model tool set was written by\n"
   " * Richard Jones, University of Connecticut.\n"
   " *\n"
   " * For more information see the following web site\n"
   " *\n"
   " * http://zeus.phys.uconn.edu/halld/datamodel/doc\n"
   " *\n"
   " */\n"
   "\n"
   "#ifndef SAW_" << classPrefix << "_HDDM\n"
   "#define SAW_" << classPrefix << "_HDDM\n"
   "\n"
   "#include <list>\n"
   "#include <deque>\n"
   "#include <vector>\n"
   "#include <string>\n"
   "#include <atomic>\n"
   "#include <sstream>\n"
   "#include <stdexcept>\n"
   "#include <streambuf>\n"
   "#include <xstream/z.h>\n"
   "#include <xstream/bz.h>\n"
   "#include <xstream/xdr.h>\n"
   "#include <xstream/digest.h>\n"
   "#include <particleType.h>\n"
   "#include <pthread.h>\n"
   "\n"
   "#define MY_SETUP thread_private_data *my_private = lookup_private_data();\n"
   "#define MY(VAR) my_private->m_ ## VAR\n"
   "\n"
   "namespace hddm_" << classPrefix << " {\n"
   "\n"
   "const int k_default_status = 0x0;\n"
   "const int k_bits_compression = 0xf0;\n"
   "const int k_no_compression = 0x00;\n"
   "const int k_z_compression = 0x10;\n"
   "const int k_bz2_compression = 0x20;\n"
   "const int k_bits_integrity = 0x0f;\n"
   "const int k_no_integrity = 0x00;\n"
   "const int k_crc32_integrity = 0x01;\n"
   "const int k_bits_randomaccess = 0xf00;\n"
   "const int k_can_reposition = 0x100;\n"
   "\n"
   "enum hddm_type {\n"
   "   k_hddm_unknown,\n"
   "   k_hddm_int,\n"
   "   k_hddm_long,\n"
   "   k_hddm_float,\n"
   "   k_hddm_double,\n"
   "   k_hddm_boolean,\n"
   "   k_hddm_string,\n"
   "   k_hddm_anyURI,\n"
   "   k_hddm_Particle_t\n"
   "};\n"
   "\n"
   "class HDDM;\n"
   "class istream;\n"
   "class ostream;\n"
   "\n"
   "class streamable {\n"
   " public:\n"
   "   virtual ~streamable() {}\n"
   "   virtual void streamer(istream &istr) {}\n"
   "   virtual void streamer(ostream &ostr) {}\n"
   "};\n"
   "\n"
   "class streamposition {\n"
   " public:\n"
   "   uint64_t block_start;\n"
   "   uint32_t block_offset;\n"
   "   uint32_t block_status;\n"
   "   streamposition();\n"
   "   streamposition(uint64_t start, uint32_t offset, uint32_t status);\n"
   "   bool operator==(const streamposition src) const {\n"
   "      return (block_start == src.block_start &&\n"
   "              block_offset == src.block_offset &&\n"
   "              block_status == src.block_status);\n"
   "   }\n"
   "   bool operator!=(const streamposition src) const {\n"
   "      return !(*this == src);\n"
   "   }\n"
   "   bool operator>(const streamposition src) const {\n"
   "      return (block_start > src.block_start ||\n"
   "              (block_start == src.block_start &&\n"
   "               block_offset > src.block_offset));\n"
   "   }\n"
   "   bool operator>=(const streamposition src) const {\n"
   "      return (*this > src || *this == src);\n"
   "   }\n"
   "   bool operator<(const streamposition src) const {\n"
   "      return !(*this >= src);\n"
   "   }\n"
   "   bool operator<=(const streamposition src) const {\n"
   "      return !(*this > src);\n"
   "   }\n"
   "};\n"
   "\n"
   "class threads {\n"
   " public:\n"
   "   static thread_local int ID;\n"
   "   static int getID() {\n"
   "      // protected access to the ID tls data member\n"
   "      if (ID == 0) {\n"
   "         if (ID >= max_threads) {\n"
   "            throw std::runtime_error(\"hddm_r::threads::getID - \"\n"
   "                            \"thread count exceeds max_threads\");\n"
   "         }\n"
   "         ID = ++next_unique_ID;\n"
   "      }\n"
   "      return ID;\n"
   "   }\n"
   "   static const int max_threads = 999;\n"
   " protected:\n"
   "   static std::atomic<int> next_unique_ID;\n"
   "};\n"
   "\n"
   "class istreambuffer : public std::streambuf {\n"
   " public:\n"
   "   istreambuffer(char* buffer, std::streamsize bufferLength) {\n"
   "      setg(buffer, buffer, buffer + bufferLength);\n"
   "   }\n"
   "\n"
   "   std::streampos tellg() {\n"
   "      return gptr() - eback();\n"
   "   }\n"
   "\n"
   "   void seekg(std::streampos pos) {\n"
   "      reset();\n"
   "      gbump(pos);\n"
   "   }\n"
   "\n"
   "   int size() {\n"
   "      return egptr() - gptr();\n"
   "   }\n"
   "\n"
   "   void reset() {\n"
   "      char *gbegin = eback();\n"
   "      char *gend = egptr();\n"
   "      setg(gbegin, gbegin, gend);\n"
   "   }\n"
   "\n"
   "   char *getbuf() {\n"
   "      return eback();\n"
   "   }\n"
   "};\n"
   "\n"
   "class ostreambuffer : public std::streambuf {\n"
   " public:\n"
   "   ostreambuffer(char* buffer, std::streamsize bufferLength) {\n"
   "      setp(buffer, buffer + bufferLength);\n"
   "   }\n"
   "\n"
   "   std::streampos tellp() {\n"
   "      return pptr() - pbase();\n"
   "   }\n"
   "\n"
   "   void seekp(std::streampos pos) {\n"
   "      reset();\n"
   "      pbump(pos);\n"
   "   }\n"
   "\n"
   "   int size() {\n"
   "      return pptr() - pbase();\n"
   "   }\n"
   "\n"
   "   void reset() {\n"
   "      char *pbegin = pbase();\n"
   "      char *pend = epptr();\n"
   "      setp(pbegin, pend);\n"
   "   }\n"
   "\n"
   "   char *getbuf() {\n"
   "      return pbase();\n"
   "   }\n"
   "};\n"
   "\n"
   "class ostream {\n"
   " public:\n"
   "   ostream(std::ostream &src);\n"
   "   ~ostream();\n"
   "   ostream &operator<<(HDDM &record);\n"
   "   int getCompression() const;\n"
   "   void setCompression(int flags);\n"
   "   int getIntegrityChecks() const;\n"
   "   void setIntegrityChecks(int flags);\n"
   "   streamposition getPosition();\n"
   "   int getBytesWritten() const;\n"
   "   int getRecordsWritten() const;\n"
   " //protected:\n"
   "   xstream::xdr::ostream *getXDRostream() {\n"
   "      return my_thread_private[threads::ID]->m_xstr;\n"
   "   }\n"
   "   ostream &operator<<(streamable &object);\n"
   " private:\n"
   "   void configure_streambufs();\n"
   "   void update_streambufs();\n"
   "   void lock_streambufs();\n"
   "   void unlock_streambufs();\n"
   "   std::ostream &m_ostr;\n"
   "   std::atomic<int> m_status_bits;\n"
   "   pthread_mutex_t m_streambuf_mutex;\n"
   "\n"
   "   typedef struct {\n"
   "      xstream::xdr::ostream *m_xstr;\n"
   "      std::ostream *m_ostr;\n"
   "      ostreambuffer *m_sbuf;\n"
   "      std::streambuf *m_xcmp;\n"
   "      char *m_event_buffer;\n"
   "      int m_event_buffer_size;\n"
   "      std::streampos m_last_start;\n"
   "      std::streamoff m_last_offset;\n"
   "      int m_status_bits;\n"
   "      int m_mutex_lock;\n"
   "      int m_bytes_written;\n"
   "      int m_records_written;\n"
   "   } thread_private_data;\n"
   "\n"
   "   thread_private_data *my_thread_private[threads::max_threads];\n"
   "   thread_private_data *lookup_private_data();\n"
   "   void init_private_data();\n"
   "};\n"
   "\n"
   "class codon {\n"
   " public:\n"
   "   codon(): m_order(0) {}\n"
   "   int m_order;\n"
   "   std::string m_tagname;\n"
   "   std::vector<codon> m_sequence;\n"
   "   std::deque<streamable*> m_target;\n"
   "};\n"
   "\n"
   "typedef std::vector<codon> chromosome;\n"
   "\n"
   "class istream {\n"
   " public:\n"
   "   istream(std::istream &src);\n"
   "   ~istream();\n"
   "   istream &operator>>(HDDM &record);\n"
   "   void skip(int count);\n"
   "   int getCompression() const;\n"
   "   int getIntegrityChecks() const;\n"
   "   streamposition getPosition();\n"
   "   void setPosition(const streamposition &pos);\n"
   "   int getBytesRead() const;\n"
   "   int getRecordsRead() const;\n"
   "   bool eof();\n"
   "   bool operator!();\n"
   "   operator void*();\n"
   " //protected:\n"
   "   void reset_sequencer();\n"
   "   void sequencer(streamable &object);\n"
   "   istream &operator>>(streamable &object);\n"
   "   xstream::xdr::istream *getXDRistream() {\n"
   "      return my_thread_private[threads::ID]->m_xstr;\n"
   "   }\n"
   "\n"
   " private:\n"
   "   std::string m_documentString;\n"
   "   chromosome synthesize(const std::string &src, int p_src,\n"
   "                         const std::string &ref, int p_ref);\n"
   "   int getTag(const std::string &src, int p_src, std::string &tag, int &level);\n"
   "   int getEndTag(const std::string &src, int p_src, const std::string &tag);\n"
   "   void collide(const std::string &itag, const std::string &rtag);\n"
   "   void configure_streambufs();\n"
   "   void update_streambufs();\n"
   "   void lock_streambufs();\n"
   "   void unlock_streambufs();\n"
   "   std::istream &m_istr;\n"
   "   std::atomic<int> m_status_bits;\n"
   "   pthread_mutex_t m_streambuf_mutex;\n"
   "   int m_leftovers[100];\n"
   "\n"
   "   typedef struct {\n"
   "      codon m_genome;\n"
   "      codon *m_codon;\n"
   "      int m_sequencing;\n"
   "      xstream::xdr::istream *m_xstr;\n"
   "      std::istream *m_istr;\n"
   "      istreambuffer *m_sbuf;\n"
   "      std::streambuf *m_xcmp;\n"
   "      int m_events_to_skip;\n"
   "      char *m_event_buffer;\n"
   "      int m_event_buffer_size;\n"
   "      int m_event_size;\n"
   "      std::streampos m_last_start;\n"
   "      std::streamoff m_last_offset;\n"
   "      std::streamoff m_next_start;\n"
   "      int m_status_bits;\n"
   "      int m_mutex_lock;\n"
   "      int m_bytes_read;\n"
   "      int m_records_read;\n"
   "      bool m_hit_eof;\n"
   "   } thread_private_data;\n"
   "\n"
   "   thread_private_data *my_thread_private[threads::max_threads];\n"
   "   thread_private_data *lookup_private_data();\n"
   "   void init_private_data();\n"
   "};\n"
   "\n"
   "template <class T> class HDDM_ElementList;\n"
   "\n"
   "class HDDM_Element: public streamable {\n"
   " public:\n"
   "   ~HDDM_Element() {}\n"
   "   virtual const void *getAttribute(const std::string &name,\n"
   "                                    hddm_type *atype=0) const {\n"
   "      return 0;\n"
   "   }\n"
   "   friend class HDDM_ElementList<HDDM_Element>;\n"
   " protected:\n"
   "   HDDM_Element() : m_parent(0), m_host(0) {}\n"
   "   HDDM_Element(HDDM_Element *parent)\n"
   "    : m_parent(parent),\n"
   "      m_host(parent->m_host)\n"
   "    {}\n"
   "   HDDM_Element(HDDM_Element &src)\n"
   "    : m_parent(src.m_parent),\n"
   "      m_host(src.m_host)\n"
   "   {}\n"
   "   HDDM_Element *m_parent;\n"
   "   HDDM *m_host;\n"
   "};\n"
   "\n"
   "template <class T>\n"
   "class HDDM_ElementList: public streamable {\n"
   " public:\n"
   "   HDDM_ElementList(typename std::list<T*> *plist,\n"
   "                    typename std::list<T*>::iterator begin,\n"
   "                    typename std::list<T*>::iterator end,\n"
   "                    HDDM_Element *parent=0)\n"
   "    : m_host_plist(plist),\n"
   "      m_first_iter(begin),\n"
   "      m_last_iter(end),\n"
   "      m_parent(parent)\n"
   "   {\n"
   "      for (m_size = 0; begin != end; ++m_size, ++begin) {}\n"
   "      if (m_size) {\n"
   "         --m_last_iter;\n"
   "      }\n"
   "   }\n"
   "\n"
   "   HDDM_ElementList(const HDDM_ElementList<T> &src)\n"
   "    : m_host_plist(src.m_host_plist),\n"
   "      m_first_iter(src.m_first_iter),\n"
   "      m_last_iter(src.m_last_iter),\n"
   "      m_parent(src.m_parent),\n"
   "      m_size(src.m_size)\n"
   "   {}\n"
   "\n"
   "   bool empty() const { return (m_size == 0); }\n"
   "   int size() const { return m_size; }\n"
   "   T &front() const { return *m_first_iter; }\n"
   "   T &back() const { return *m_last_iter; }\n"
   "   T &operator()() { return *m_first_iter; }\n"
   "   T &operator()(int index) {\n"
   "      if (index == 0) {\n"
   "         return *m_first_iter;\n"
   "      }\n"
   "      else if (index == -1) {\n"
   "         return *m_last_iter;\n"
   "      }\n"
   "      else if (index > 0) {\n"
   "         return *(m_first_iter + index);\n"
   "      }\n"
   "      else {\n"
   "         return *(m_last_iter + (++index));\n"
   "      }\n"
   "   }\n"
   "\n"
   "   class iterator: public std::list<T*>::iterator {\n"
   "    public:\n"
   "      iterator() {}\n"
   "      iterator(typename std::list<T*>::iterator src)\n"
   "       : std::list<T*>::iterator(src) {}\n"
   "\n"
   "      T *operator->() const { \n"
   "         return *(typename std::list<T*>::iterator)(*this);\n"
   "      }\n"
   "\n"
   "      T &operator*() const {\n"
   "         return **(typename std::list<T*>::iterator)(*this);\n"
   "      }\n"
   "\n"
   "      iterator operator+=(int offset) {\n"
   "         if (offset > 0) {\n"
   "            for (int i=0; i<offset; ++i, ++(*this)) {}\n"
   "         }\n"
   "         else if (offset < 0) {\n"
   "            for (int i=0; i>offset; --i, --(*this)) {}\n"
   "         }\n"
   "         return *this;\n"
   "      }\n"
   "\n"
   "      iterator operator-=(int offset) {\n"
   "         if (offset > 0) {\n"
   "            for (int i=0; i<offset; ++i, --(*this)) {}\n"
   "         }\n"
   "         else if (offset < 0) {\n"
   "            for (int i=0; i>offset; --i, ++(*this)) {}\n"
   "         }\n"
   "         return *this;\n"
   "      }\n"
   "\n"
   "      iterator operator+(int offset) const {\n"
   "         iterator iter(*this);\n"
   "         return iter += offset;\n"
   "      }\n"
   "\n"
   "      iterator operator-(int offset) const {\n"
   "         iterator iter(*this);\n"
   "         return iter -= offset;\n"
   "      }\n"
   "\n"
   "      int operator-(iterator iter) const {\n"
   "         if (*this == iter) {\n"
   "            return 0;\n"
   "         }\n"
   "         iterator iter2(iter);\n"
   "         for (int n=1; n < m_size; ++n) {\n"
   "            if (++iter == *this) {\n"
   "               return n;\n"
   "            }\n"
   "            else if (--iter2 == *this) {\n"
   "               return -n;\n"
   "            }\n"
   "         }\n"
   "         return m_size;\n"
   "      }\n"
   "   };\n"
   "\n"
   "   class const_iterator: public std::list<T*>::const_iterator {\n"
   "    public:\n"
   "      const_iterator() {}\n"
   "      const_iterator(const typename std::list<T*>::const_iterator src)\n"
   "       : std::list<T*>::const_iterator(src) {}\n"
   "\n"
   "      const_iterator(const typename std::list<T*>::iterator src)\n"
   "       : std::list<T*>::const_iterator(src) {}\n"
   "\n"
   "      const T *operator->() const { \n"
   "         return *(typename std::list<T*>::const_iterator)(*this);\n"
   "      }\n"
   "\n"
   "      const T &operator*() const { \n"
   "         return **(typename std::list<T*>::const_iterator)(*this);\n"
   "      }\n"
   "\n"
   "      const const_iterator operator+=(int offset) {\n"
   "         if (offset > 0) {\n"
   "            for (int i=0; i<offset; ++i, ++(*this)) {}\n"
   "         }\n"
   "         else if (offset < 0) {\n"
   "            for (int i=0; i>offset; --i, --(*this)) {}\n"
   "         }\n"
   "         return *this;\n"
   "      }\n"
   "\n"
   "      const const_iterator operator-=(int offset) {\n"
   "         if (offset > 0) {\n"
   "            for (int i=0; i<offset; ++i, --(*this)) {}\n"
   "         }\n"
   "         else if (offset > 0) {\n"
   "            for (int i=0; i>offset; --i, ++(*this)) {}\n"
   "         }\n"
   "         return *this;\n"
   "      }\n"
   "\n"
   "      const const_iterator operator+(int offset) const {\n"
   "         const_iterator iter(*this);\n"
   "         return iter += offset;\n"
   "      }\n"
   "\n"
   "      const const_iterator operator-(int offset) const {\n"
   "         const_iterator iter(*this);\n"
   "         return iter -= offset;\n"
   "      }\n"
   "\n"
   "      int operator-(const_iterator iter) const {\n"
   "         if (*this == iter) {\n"
   "            return 0;\n"
   "         }\n"
   "         const_iterator iter2(iter);\n"
   "         for (int n=1; n < m_size; ++n) {\n"
   "            if (++iter == *this) {\n"
   "               return n;\n"
   "            }\n"
   "            else if (--iter2 == *this) {\n"
   "               return -n;\n"
   "            }\n"
   "         }\n"
   "         return m_size;\n"
   "      }\n"
   "   };\n"
   "\n"
   "   iterator begin() const { return m_first_iter; }\n"
   "   iterator end() const { return (m_size)? m_last_iter + 1 : m_last_iter; }\n"
   "   void clear() { del(); }\n"
   "\n"
   "   HDDM_ElementList add(int count=1, int start=-1) {\n"
   "      if (m_parent == 0) {\n"
   "         throw std::runtime_error(\"HDDM_ElementList error - \"\n"
   "                                  \"attempt to add to immutable list\");\n"
   "      }\n"
   "      iterator it = insert(start, count);\n"
   "      typename std::list<T*>::iterator iter(it);\n"
   "      for (int n=0; n<count; ++n, ++iter) {\n"
   "         *iter = new T(m_parent);\n"
   "      }\n"
   "      return HDDM_ElementList(m_host_plist, it, it+count, m_parent);\n"
   "   }\n"
   "\n"
   "   void del(int count=-1, int start=0) {\n"
   "      if (m_parent == 0) {\n"
   "         throw std::runtime_error(\"HDDM_ElementList error - \"\n"
   "                                  \"attempt to delete from immutable list\");\n"
   "      }\n"
   "      iterator iter_begin(begin());\n"
   "      iterator iter_end(end());\n"
   "      if (start < 0) {\n"
   "         if (count >= 0) {\n"
   "            iter_begin = iter_end - count;\n"
   "         }\n"
   "      }\n"
   "      else {\n"
   "         iter_begin += start;\n"
   "         if (count >= 0) {\n"
   "            iter_end = iter_begin + start;\n"
   "         }\n"
   "      }\n"
   "      typename std::list<T*>::iterator iter;\n"
   "      for (iter = iter_begin; iter != iter_end; ++iter) {\n"
   "         delete *iter;\n"
   "      }\n"
   "      erase(start, count);\n"
   "   }\n"
   "\n"
   "   HDDM_ElementList slice(int first=0, int last=-1) {\n"
   "      int n1 = (first < 0)? first + m_size : first;\n"
   "      int n2 = (last < 0)? last + m_size + 1 : last + 1;\n"
   "      int count = n2 - n1;\n"
   "      iterator iter_begin;\n"
   "      if (first > 0)\n"
   "         iter_begin = begin() + first;\n"
   "      else if (first < 0)\n"
   "         iter_begin = end() + first;\n"
   "      iterator iter_end(iter_begin + count);\n"
   "      return HDDM_ElementList(m_host_plist, iter_begin, iter_end, m_parent);\n"
   "   }\n"
   "\n"
   "   void streamer(istream &istr) {\n"
   "      clear();\n"
   "      int size;\n"
   "      *istr.getXDRistream() >> size;\n"
   "      if (size) {\n"
   "         iterator iter = add(size).begin();\n"
   "         for (int n=0; n < size; ++n, ++iter) {\n"
   "            istr.sequencer(*iter);\n"
   "         }\n"
   "      }\n"
   "      istr.reset_sequencer();\n"
   "   }\n"
   "\n"
   "   void streamer(ostream &ostr) {\n"
   "      if (m_size) {\n"
   "         *ostr.getXDRostream() << m_size;\n"
   "         for (iterator iter = begin(); iter != end(); ++iter) {\n"
   "            iter->streamer(ostr);\n"
   "         }\n"
   "      }\n"
   "   }\n"
   "\n"
   " private:\n"
   "   HDDM_ElementList() {}\n"
   "\n"
   "   iterator insert(int start, int count) {\n"
   "      if (m_size == 0) {\n"
   "         if (count > 0) {\n"
   "            if (m_first_iter == m_host_plist->begin()) {\n"
   "               m_host_plist->insert(m_first_iter,count,(T*)0);\n"
   "               m_first_iter = m_host_plist->begin();\n"
   "            }\n"
   "            else {\n"
   "               m_host_plist->insert(m_first_iter--,count,(T*)0);\n"
   "               ++m_first_iter;\n"
   "            }\n"
   "            --m_last_iter;\n"
   "            m_size = count;\n"
   "         }\n"
   "         return m_first_iter;\n"
   "      }\n"
   "      else if (start == 0) {\n"
   "         if (count > 0) {\n"
   "            if (m_first_iter == m_host_plist->begin()) {\n"
   "               m_host_plist->insert(m_first_iter,count,(T*)0);\n"
   "               m_first_iter = m_host_plist->begin();\n"
   "            }\n"
   "            else {\n"
   "               m_host_plist->insert(m_first_iter--,count,(T*)0);\n"
   "               ++m_first_iter;\n"
   "            }\n"
   "            m_size += count;\n"
   "         }\n"
   "         return m_first_iter;\n"
   "      }\n"
   "      else if (start == -1) {\n"
   "         if (count > 0) {\n"
   "            iterator pos(m_last_iter);\n"
   "            m_host_plist->insert(++m_last_iter,count,(T*)0);\n"
   "            --m_last_iter;\n"
   "            m_size += count;\n"
   "            return ++pos;\n"
   "         }\n"
   "         return m_last_iter;\n"
   "      }\n"
   "      else if (start > 0) {\n"
   "         if (count > 0) {\n"
   "            iterator pos(m_first_iter);\n"
   "            iterator pos2(pos += start-1);\n"
   "            m_host_plist->insert(++pos,count,(T*)0);\n"
   "            if (m_last_iter == pos2) {\n"
   "               m_last_iter = --pos;\n"
   "            }\n"
   "            m_size += count;\n"
   "            return ++pos2;\n"
   "         }\n"
   "         return m_first_iter + start;\n"
   "      }\n"
   "      else {\n"
   "         if (count > 0) {\n"
   "            iterator pos(m_last_iter);\n"
   "            iterator pos2(pos += start);\n"
   "            m_host_plist->insert(++pos,count,(T*)0);\n"
   "            m_size += count;\n"
   "            return ++pos2;\n"
   "         }\n"
   "         return m_last_iter + (start+1);\n"
   "      }\n"
   "   }\n"
   "\n"
   "   iterator erase(int start, int count) {\n"
   "      if (m_size == 0) {\n"
   "         return m_first_iter+start;\n"
   "      }\n"
   "      else if ((count >= m_size || count == -1) &&\n"
   "               (start == 0 || start <= -m_size)) {\n"
   "         m_host_plist->erase(m_first_iter,++m_last_iter);\n"
   "         m_first_iter = m_last_iter;\n"
   "         m_size = 0;\n"
   "         return m_first_iter;\n"
   "      }\n"
   "      else if (start > 0 && start <= m_size) {\n"
   "         ++m_last_iter;\n"
   "         count = (count < 0)? m_size-start : count;\n"
   "         iterator pos(m_first_iter + start);\n"
   "         iterator pos2(pos + count);\n"
   "         m_host_plist->erase(pos,pos2);\n"
   "         m_size -= count;\n"
   "         --m_last_iter;\n"
   "         return pos2;\n"
   "      }\n"
   "      else if (start < 0 && start >= -m_size) {\n"
   "         ++m_last_iter;\n"
   "         count = (count < 0)? -start : count;\n"
   "         iterator pos(m_last_iter + (start+1));\n"
   "         iterator pos2(pos + count);\n"
   "         m_host_plist->erase(pos,pos2);\n"
   "         if (m_size -= count) {\n"
   "            --m_last_iter;\n"
   "         }\n"
   "         else {\n"
   "            m_first_iter = m_last_iter;\n"
   "         }\n"
   "         return pos2;\n"
   "      }\n"
   "      return m_last_iter+1;\n"
   "   }\n"
   "\n"
   " protected:\n"
   "   std::list<T*> *m_host_plist;\n"
   "   iterator m_first_iter;\n"
   "   iterator m_last_iter;\n"
   "   HDDM_Element *m_parent;\n"
   "   int m_size;\n"
   "};\n"
   "\n"
   "template <class T>\n"
   "class HDDM_ElementLink: public HDDM_ElementList<T> {\n"
   " public:\n"
   "   HDDM_ElementLink(typename std::list<T*> *plist,\n"
   "                    typename std::list<T*>::iterator begin,\n"
   "                    typename std::list<T*>::iterator end,\n"
   "                    HDDM_Element *parent)\n"
   "    : HDDM_ElementList<T>(plist,begin,end,parent)\n"
   "   {}\n"
   "   HDDM_ElementLink(const HDDM_ElementList<T> &src)\n"
   "    : HDDM_ElementList<T>(src)\n"
   "   {}\n"
   "\n"
   "   void streamer(istream &istr) {\n"
   "      HDDM_ElementList<T>::clear();\n"
   "      HDDM_ElementList<T>::add().begin()->streamer(istr);\n"
   "   }\n"
   "\n"
   "   void streamer(ostream &ostr) {\n"
   "      if (HDDM_ElementList<T>::m_size) {\n"
   "         HDDM_ElementList<T>::begin()->streamer(ostr);\n"
   "      }\n"
   "   }\n"
   "\n"
   " protected:\n"
   "   HDDM_ElementLink() {}\n"
   "};\n"
   "\n"
   ;

   builder.cFile <<
   "/*\n"
   " * hddm_" << classPrefix << ".cpp - DO NOT EDIT THIS FILE\n"
   " *\n"
   " * This file was generated automatically by hddm-cpp from the file\n"
   << " * " << xmlFile << std::endl <<
   "\n"
   " * This c++ source implements the methods for the classes \n"
   " * described in the data model (from " << xmlFile << "). \n"
   " *\n"
   " * The hddm data model tool set was written by\n"
   " * Richard Jones, University of Connecticut.\n"
   " *\n"
   " * For more information see the following web site\n"
   " *\n"
   " * http://zeus.phys.uconn.edu/halld/datamodel/doc\n"
   " */\n"
   "\n"
   "#include <sstream>\n"
   "#include \"hddm_" << classPrefix << ".hpp\"\n"
   "\n"
   "#ifndef _FILE_OFFSET_BITS\n"
   "# define _FILE_OFFSET_BITS 64\n"
   "#endif\n"
   "\n"
   "using namespace hddm_" << classPrefix << ";\n"
   "\n"
   "std::atomic<int> threads::next_unique_ID(0);\n"
   "thread_local int threads::ID(0);\n"
   "\n"
   "static int tags_match(const std::string &a, const std::string &b)\n"
   "{\n"
   "   if (a == b) {\n"
   "      return true;\n"
   "   }\n"
   "   else {\n"
   "      int len = a.length();\n"
   "      int ia=0;\n"
   "      int ib=0;\n"
   "      for (; a[ia] == b[ib]; ++ia, ++ib, --len) {}\n"
   "      for (; a[ia] == ' '; ++ia, --len) {}\n"
   "      for (; a[ia] == '/'; ++ia, --len) {}\n"
   "      for (; b[ib] == ' '; ++ib) {}\n"
   "      for (; b[ib] == '/'; ++ib) {}\n"
   "      return (a.substr(ia) == b.substr(ib));\n"
   "   }\n"
   "}\n"
   "\n"
   ;

   builder.constructGroup(rootEl);
   builder.constructIOstreams(rootEl);
   builder.constructMethods(rootEl);
   builder.constructStreamers(rootEl);

   builder.hFile <<
   "inline std::string HDDM::DocumentString() {\n"
   "   return std::string(\n"
   ;
   builder.constructDocument(rootEl);
   builder.hFile <<
   "   );\n"
   "}\n"
   "\n"
   "}\n"
   "#endif /* SAW_" << classPrefix << "_HDDM */\n"
   ;

   builder.cFile <<
   "\n"
   "streamposition::streamposition()\n"
   " : block_start(), block_offset(), block_status() {}\n"
   "\n"
   "streamposition::streamposition(uint64_t start, uint32_t offset, uint32_t status)\n"
   " : block_start(start), block_offset(offset), block_status(status) {}\n"
   "\n"
   "istream::istream(std::istream &src)\n"
   " : m_istr(src),\n"
   "   m_status_bits(0)\n"
   "{\n"
   "   char hdr[10];\n"
   "   src.getline(hdr,7);\n"
   "   m_documentString = hdr;\n"
   "   if (m_documentString != \"<HDDM \") {\n"
   "      throw std::runtime_error(\"hddm_" + classPrefix +
   "::istream::istream error - invalid hddm header\");\n"
   "   }\n"
   "   src.clear();\n"
   "   std::string line;\n"
   "   while (std::getline(src,line).good()) {\n"
   "      m_documentString += line + \"\\n\";\n"
   "      if (line == \"</HDDM>\") {\n"
   "         break;\n"
   "      }\n"
   "   }\n"
   "   if (src.bad()) {\n"
   "      throw std::runtime_error(\"hddm_" + classPrefix +
   "::istream::istream error - invalid hddm header\");\n"
   "   }\n"
   "   pthread_mutex_init(&m_streambuf_mutex,0);\n"
   "   for (int i=0; i<threads::max_threads; ++i) {\n"
   "      my_thread_private[i] = 0;\n"
   "   }\n"
   "   m_leftovers[0] = 0;\n"
   "   init_private_data();\n"
   "}\n"
   "\n"
   "istream::~istream() {\n"
   "   pthread_mutex_destroy(&m_streambuf_mutex);\n"
   "   for (int i=0; i<threads::max_threads; ++i) {\n"
   "      thread_private_data *my_private = my_thread_private[i];\n"
   "      if (my_private != 0) {\n"
   "         if (MY(istr))\n"
   "            delete MY(istr);\n"
   "         if (MY(xcmp))\n"
   "            delete MY(xcmp);\n"
   "         if (MY(xstr))\n"
   "            delete MY(xstr);\n"
   "         if (MY(sbuf))\n"
   "            delete MY(sbuf);\n"
   "         delete [] MY(event_buffer);\n"
   "         delete my_private;\n"
   "      }\n"
   "   }\n"
   "}\n"
   "\n"
   "void istream::init_private_data() {\n"
   "   int threadID = threads::getID();\n"
   "   if (my_thread_private[threadID] == 0) {\n"
   "      my_thread_private[threadID] = new thread_private_data;\n"
   "   }\n"
   "   MY_SETUP\n"
   "   MY(genome).m_tagname = \"HDDM\";\n"
   "   MY(genome).m_sequence = synthesize(m_documentString,0,HDDM::DocumentString(),0);\n"
   "   MY(event_buffer) = new char[MY(event_buffer_size) = 100000];\n"
   "   MY(sbuf) = new istreambuffer(MY(event_buffer),MY(event_buffer_size));\n"
   "   MY(xstr) = new xstream::xdr::istream(MY(sbuf));\n"
   "   MY(istr) = new std::istream(m_istr.rdbuf());\n"
   "   MY(xcmp) = 0;\n"
   "   MY(event_size) = 0;\n"
   "   MY(last_start) = 0;\n"
   "   MY(last_offset) = 0;\n"
   "   MY(next_start) = 0;\n"
   "   MY(events_to_skip) = 0;\n"
   "   MY(status_bits) = 0;\n"
   "   MY(mutex_lock) = 0;\n"
   "   MY(bytes_read) = 0;\n"
   "   MY(records_read) = 0;\n"
   "   MY(sequencing) = 0;\n"
   "   MY(hit_eof) = 0;\n"
   "}\n"
   "\n"
   "streamposition istream::getPosition() {\n"
   "   MY_SETUP\n"
   "   streamposition pos;\n"
   "   pos.block_start = MY(last_start);\n"
   "   pos.block_offset = MY(last_offset);\n"
   "   pos.block_status = MY(status_bits);\n"
   "   return pos;\n"
   "}\n"
   "\n"
   "void istream::setPosition(const streamposition &pos) {\n"
   "   MY_SETUP\n"
   "   m_status_bits = pos.block_status;\n"
   "   lock_streambufs();\n"
   "   update_streambufs();\n"
   "   unlock_streambufs();\n"
   "   if (MY(status_bits) & (k_bz2_compression | k_z_compression)) {\n"
   "      if (((int)m_status_bits & k_bits_compression) != 0 &&\n"
   "          ((int)m_status_bits & k_can_reposition) == 0)\n"
   "      {\n"
   "         throw std::runtime_error(\"hddm_r::istream::setPosition error - \"\n"
   "               \"old-format hddm input file does not support repositioning.\");\n"
   "      }\n"
   "      else if (MY(xcmp) == 0) {\n"
   "         throw std::runtime_error(\"hddm_r::istream::setPosition error - \"\n"
   "               \"compressed stream encountered but no decompressor configured.\");\n"
   "      }\n"
   "      if (MY(status_bits) & k_z_compression) {\n"
   "         ((xstream::z::istreambuf*)MY(xcmp))->\n"
   "             set_new_position(pos.block_start, pos.block_offset);\n"
   "      }\n"
   "      else if (MY(status_bits) & k_bz2_compression) {\n"
   "         ((xstream::bz::istreambuf*)MY(xcmp))->\n"
   "             set_new_position(pos.block_start, pos.block_offset);\n"
   "      }\n"
   "   }\n"
   "   else {\n"
   "      MY(next_start) = pos.block_start;\n"
   "   }\n"
   "}\n"
   "\n"
   "void istream::update_streambufs() {\n"
   "   MY_SETUP\n"
   "   if ((int)m_status_bits != MY(status_bits)) {\n"
   "      configure_streambufs();\n"
   "   }\n"
   "}\n"
   "\n" 
   "void istream::configure_streambufs() {\n"
   "   MY_SETUP\n"
   "   int oldcmp = MY(status_bits) & k_bits_compression;\n"
   "   int newcmp = (int)m_status_bits & k_bits_compression;\n"
   "   if (oldcmp != newcmp) {\n"
   "      if (oldcmp != k_no_compression) {\n"
   "         MY(istr)->rdbuf(m_istr.rdbuf());\n"
   "         delete MY(xcmp);\n"
   "         MY(xcmp) = 0;\n"
   "      }\n"
   "      if (newcmp == k_z_compression) {\n"
   "         //std::cerr << \"input switched on z compression\" << std::endl;\n"
   "         MY(xcmp) = new xstream::z::istreambuf(m_istr.rdbuf(), m_leftovers,\n"
   "                                                        sizeof(m_leftovers));\n"
   "         MY(istr)->rdbuf(MY(xcmp));\n"
   "      }\n"
   "      else if (newcmp == k_bz2_compression) {\n"
   "         //std::cerr << \"input switched on bz2 compression\" << std::endl;\n"
   "         MY(xcmp) = new xstream::bz::istreambuf(m_istr.rdbuf(), m_leftovers,\n"
   "                                                         sizeof(m_leftovers));\n"
   "         MY(istr)->rdbuf(MY(xcmp));\n"
   "      }\n"
   "      else if (newcmp != k_no_compression) {\n"
   "         throw std::runtime_error(\"hddm_r::istream::configure_streambufs error - \"\n"
   "                                  \"unrecognized compression flag requested.\");\n"
   "      }\n"
   "   }\n"
   "   MY(status_bits) = m_status_bits;\n"
   "}\n"
   "\n"
   "void istream::lock_streambufs() {\n"
   "   MY_SETUP\n"
   "   if (MY(mutex_lock) != 0) {\n"
   "      unlock_streambufs();\n"
   "      throw std::runtime_error(\"hddm_r::istream::lock_streambufs error - \"\n"
   "                               \"mutex lock requested when lock already held.\");\n"
   "   }\n"
   "   if ((MY(status_bits) & k_bits_compression) == k_no_compression) {\n"
   "      pthread_mutex_lock(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 1;\n"
   "   }\n"
   "   else if ((MY(status_bits) & k_bits_compression) == k_z_compression) {\n"
   "      ((xstream::z::istreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 2;\n"
   "   }\n"
   "   else if ((MY(status_bits) & k_bits_compression) == k_bz2_compression) {\n"
   "      ((xstream::bz::istreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 3;\n"
   "   }\n"
   "   else {\n"
   "      MY(mutex_lock) = -1;\n"
   "   }\n"
   "}\n"
   "\n"
   "void istream::unlock_streambufs() {\n"
   "   MY_SETUP\n"
   "   if (MY(mutex_lock) == 0) {\n"
   "      throw std::runtime_error(\"hddm_r::istream::unlock_streambufs error - \"\n"
   "                               \"mutex unlock requested when lock not held.\");\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 1) {\n"
   "      pthread_mutex_unlock(&m_streambuf_mutex);\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 2) {\n"
   "      ((xstream::z::istreambuf*)MY(xcmp))->set_streambuf_mutex(0);\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 3) {\n"
   "      ((xstream::bz::istreambuf*)MY(xcmp))->set_streambuf_mutex(0);\n"
   "   }\n"
   "   MY(mutex_lock) = 0;\n"
   "}\n"
   "\n"
   "istream &istream::operator>>(HDDM &record) {\n"
   "   MY_SETUP\n"
   "   lock_streambufs();\n"
   "   MY(event_size) = 0;\n"
   "   while (MY(event_size) == 0) {\n"
   "      update_streambufs();\n"
   "      if (MY(status_bits) & (k_bz2_compression | k_z_compression)) {\n"
   "         if (MY(status_bits) & k_can_reposition) {\n"
   "            MY(istr)->read(MY(event_buffer),4);\n"
   "            MY(bytes_read) += MY(istr)->gcount();\n"
   "            if (!MY(istr)->good()) {\n"
   "               unlock_streambufs();\n"
   "               MY(hit_eof) = 1;\n"
   "               return *this;\n"
   "            }\n"
   "            if (MY(status_bits) & k_bz2_compression) {\n"
   "               MY(last_start)  = dynamic_cast<xstream::bz::istreambuf*>\n"
   "                                 (MY(xcmp))->get_block_start();\n"
   "               MY(last_offset) = dynamic_cast<xstream::bz::istreambuf*>\n"
   "                                 (MY(xcmp))->get_block_offset();\n"
   "            }\n"
   "            else {\n"
   "               MY(last_start)  = dynamic_cast<xstream::z::istreambuf*>\n"
   "                                 (MY(xcmp))->get_block_start();\n"
   "               MY(last_offset) = dynamic_cast<xstream::z::istreambuf*>\n"
   "                                 (MY(xcmp))->get_block_offset();\n"
   "            }\n"
   "            MY(last_offset) -= 4;\n"
   "         }\n"
   "         else {\n"
   "            MY(last_start) = 0;\n"
   "            MY(last_offset) = 0;\n"
   "         }\n"
   "      }\n"
   "      else {\n"
   "         if (MY(next_start) > 0) {\n"
   "            m_istr.seekg(MY(next_start), std::ios_base::beg);\n"
   "            MY(last_start) = MY(next_start);\n"
   "            MY(last_offset) = 0;\n"
   "            MY(next_start) = 0;\n"
   "         }\n"
   "         else {\n"
   "            MY(last_start) = m_istr.tellg();\n"
   "            MY(last_offset) = 0;\n"
   "         }\n"
   "         MY(istr)->read(MY(event_buffer),4);\n"
   "         MY(bytes_read) += MY(istr)->gcount();\n"
   "         if (!MY(istr)->good()) {\n"
   "            unlock_streambufs();\n"
   "            MY(hit_eof) = 1;\n"
   "            return *this;\n"
   "         }\n"
   "      }\n"
   "      MY(hit_eof) = 0;\n"
   "      MY(sbuf)->reset();\n"
   "      *MY(xstr) >> MY(event_size);\n"
   "      if (MY(event_size) == 1) {\n"
   "         MY(istr)->read(MY(event_buffer)+4,4);\n"
   "         MY(bytes_read) += MY(istr)->gcount();\n"
   "         if (!MY(istr)->good()) {\n"
   "            unlock_streambufs();\n"
   "            throw std::runtime_error(\"hddm_r::istream::operator>> error -\"\n"
   "                                     \" read error on token input!\");\n"
   "         }\n"
   "         int size;\n"
   "         *MY(xstr) >> size;\n"
   "         MY(istr)->read(MY(event_buffer)+8,size);\n"
   "         MY(bytes_read) += MY(istr)->gcount();\n"
   "         if (!MY(istr)->good()) {\n"
   "            unlock_streambufs();\n"
   "            throw std::runtime_error(\"hddm_r::istream::operator>> error -\"\n"
   "                                     \" read error on token input!\");\n"
   "         }\n"
   "         int format, flags;\n"
   "         *MY(xstr) >> format >> flags;\n"
   "         if (format != 0) {\n"
   "            unlock_streambufs();\n"
   "            throw std::runtime_error(\"hddm_r::istream::operator>> error - \"\n"
   "                                     \"unsupported compression format!\");\n"
   "         }\n"
   "         m_status_bits.store(flags);\n"
   "         MY(event_size) = 0;\n"
   "      }\n"
   "   }\n"
   "   if (MY(event_size)+8 > MY(event_buffer_size)) {\n"
   "      delete MY(xstr);\n"
   "      delete MY(sbuf);\n"
   "      char *newbuf = new char[MY(event_buffer_size) = MY(event_size)+1000];\n"
   "      MY(sbuf) = new istreambuffer(newbuf, MY(event_buffer_size));\n"
   "      MY(xstr) = new xstream::xdr::istream(MY(sbuf));\n"
   "      memcpy(newbuf,MY(event_buffer),4);\n"
   "      delete [] MY(event_buffer);\n"
   "      MY(event_buffer) = newbuf;\n"
   "   }\n"
   "   MY(istr)->read(MY(event_buffer)+4,MY(event_size));\n"
   "   MY(bytes_read) += MY(istr)->gcount();\n"
   "   MY(records_read)++;\n"
   "   if (!MY(istr)->good()) {\n"
   "      unlock_streambufs();\n"
   "      throw std::runtime_error(\"hddm_r::istream::operator>> error -\"\n"
   "                               \" read error in mid-record!\");\n"
   "   }\n"
   "   if ((MY(status_bits) & k_crc32_integrity) != 0) {\n"
   "      unsigned int recorded_crc;\n"
   "      char crcbuf[10];\n"
   "      istreambuffer sbuf(crcbuf,10);\n"
   "      xstream::xdr::istream xstr(&sbuf);\n"
   "      MY(istr)->read(crcbuf,4);\n"
   "      MY(bytes_read) += MY(istr)->gcount();\n"
   "      xstr >> recorded_crc;\n"
   "      xstream::digest::crc32 crc;\n"
   "      std::ostream out(&crc);\n"
   "      out.write(MY(event_buffer),MY(event_size)+4);\n"
   "      out.flush();\n"
   "      if (crc.digest() != recorded_crc) {\n"
   "         char errmsg[] = \n"
   "              \"WARNING: crc data integrity check failed\"\n"
   "              \" on hddm_r input stream!\"\n"
   "              \"\\nThis may be the result of a bug in the\"\n"
   "              \" xstream library if you are analyzing a data\"\n"
   "              \" file that was generated by code prior to svn\"\n"
   "              \" rev 18530.\\nIf this concerns you, regenerate\"\n"
   "              \" using a newer build of the sim-recon tools\"\n"
   "              \" and it should go away.\\n\";\n"
   "         if ((MY(status_bits) & 0x02) == 0) {\n"
   "            std::cerr << errmsg << std::endl;\n"
   "            MY(status_bits) |= 0x02;\n"
   "         }\n"
   "         //unlock_streambufs();\n"
   "         //throw std::runtime_error(\"hddm_r::istream::operator>> error -\"\n"
   "         //                         \" crc check error on input stream!\");\n"
   "      }\n"
   "   }\n"
   "   unlock_streambufs();\n"
   "   if (MY(events_to_skip)) {\n"
   "      --MY(events_to_skip);\n"
   "      return *this >> record;\n"
   "   }\n"
   "   MY(sbuf)->reset();\n"
   "   MY(sequencing) = 0;\n"
   "   MY(codon) = &MY(genome);\n"
   "   *this >> (streamable&)record;\n"
   "   return *this;\n"
   "}\n"
   "\n"
   "ostream::ostream(std::ostream &src)\n"
   " : m_ostr(src),\n"
   "   m_status_bits(k_default_status)\n"
   "{\n"
   "   m_ostr << HDDM::DocumentString();\n"
   "   if (!m_ostr.good()) {\n"
   "      throw std::runtime_error(\"hddm_" + classPrefix +
   "::ostream::ostream(ostream) \"\n"
   "                          \"error - write error on header output!\");\n"
   "   }\n"
   "   pthread_mutex_init(&m_streambuf_mutex,0);\n"
   "   for (int i=0; i<threads::max_threads; ++i) {\n"
   "      my_thread_private[i] = 0;\n"
   "   }\n"
   "   init_private_data();\n"
   "}\n"
   "\n"
   "ostream::~ostream() {\n"
   "   pthread_mutex_destroy(&m_streambuf_mutex);\n"
   "   for (int i=0; i<threads::max_threads; ++i) {\n"
   "      thread_private_data *my_private = my_thread_private[i];\n"
   "      if (my_private != 0) {\n"
   "         if (MY(xstr)) {\n"
   "            delete MY(xstr);\n"
   "         }\n"
   "         if (MY(ostr)) {\n"
   "            MY(ostr)->flush();\n"
   "            delete MY(ostr);\n"
   "         }\n"
   "         if (MY(xcmp)) {\n"
   "            delete MY(xcmp);\n"
   "         }\n"
   "         if (MY(sbuf)) {\n"
   "            delete MY(sbuf);\n"
   "         }\n"
   "         delete [] MY(event_buffer);\n"
   "         delete my_private;\n"
   "      }\n"
   "   }\n"
   "}\n"
   "\n"
   "void ostream::init_private_data() {\n"
   "   int threadID = threads::getID();\n"
   "   if (my_thread_private[threadID] == 0) {\n"
   "      my_thread_private[threadID] = new thread_private_data;\n"
   "   }\n"
   "   MY_SETUP\n"
   "   MY(event_buffer) = new char[MY(event_buffer_size) = 100000];\n"
   "   MY(sbuf) = new ostreambuffer(MY(event_buffer),MY(event_buffer_size));\n"
   "   MY(xstr) = new xstream::xdr::ostream(MY(sbuf));\n"
   "   MY(ostr) = new std::ostream(m_ostr.rdbuf());\n"
   "   MY(xcmp) = 0;\n"
   "   MY(last_start) = 0;\n"
   "   MY(last_offset) = 0;\n"
   "   MY(records_written) = 0;\n"
   "   MY(bytes_written) = 0;\n"
   "   MY(status_bits) = 0;\n"
   "   MY(mutex_lock) = 0;\n"
   "}\n"
   "\n"
   "void ostream::setCompression(int flags) {\n"
   "   MY_SETUP\n"
   "   int oldcmp = (int)m_status_bits & k_bits_compression;\n"
   "   int newcmp = flags & k_bits_compression;\n"
   "   if (oldcmp != newcmp) {\n"
   "      m_status_bits.fetch_and(~k_bits_compression | flags);\n"
   "      m_status_bits.fetch_or(k_bits_compression & flags);\n"
   "      if (newcmp != 0)\n"
   "         m_status_bits.fetch_or(k_can_reposition);\n"
   "      MY(sbuf)->reset();\n"
   "      *MY(xstr) << 1 << 8 << 0 << (int)m_status_bits;\n"
   "      lock_streambufs();\n"
   "      MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());\n"
   "      if (!MY(ostr)->good()) {\n"
   "         unlock_streambufs();\n"
   "         throw std::runtime_error(\"hddm_r::ostream::setCompression\"\n"
   "                                  \" error - write error on token output!\");\n"
   "      }\n"
   "      unlock_streambufs();\n"
   "   }\n"
   "}\n"
   "\n"
   "void ostream::setIntegrityChecks(int flags) {\n"
   "   MY_SETUP\n"
   "   int oldint = (int)m_status_bits & k_bits_integrity;\n"
   "   int newint = flags & k_bits_integrity;\n"
   "   if (oldint != newint) {\n"
   "      m_status_bits.fetch_and(~k_bits_integrity | flags);\n"
   "      m_status_bits.fetch_or(k_bits_integrity & flags);\n"
   "      MY(sbuf)->reset();\n"
   "      *MY(xstr) << 1 << 8 << 0 << (int)m_status_bits;\n"
   "      lock_streambufs();\n"
   "      MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());\n"
   "      if (!MY(ostr)->good()) {\n"
   "         unlock_streambufs();\n"
   "         throw std::runtime_error(\"hddm_r::ostream::setIntegrityChecks\"\n"
   "                                  \" error - write error on token output!\");\n"
   "      }\n"
   "      unlock_streambufs();\n"
   "   }\n"
   "}\n"
   "\n" 
   "streamposition ostream::getPosition() {\n"
   "   MY_SETUP\n"
   "   streamposition pos;\n"
   "   pos.block_start = MY(last_start);\n"
   "   pos.block_start = MY(last_offset);\n"
   "   pos.block_status = MY(status_bits);\n"
   "   return pos;\n"
   "}\n"
   "\n"
   "void ostream::update_streambufs() {\n"
   "   MY_SETUP\n"
   "   if ((int)m_status_bits != MY(status_bits)) {\n"
   "      configure_streambufs();\n"
   "   }\n"
   "}\n"
   "\n"
   "void ostream::configure_streambufs() {\n"
   "   MY_SETUP\n"
   "   int oldcmp = MY(status_bits) & k_bits_compression;\n"
   "   int newcmp = (int)m_status_bits & k_bits_compression;\n"
   "   if (oldcmp != newcmp) {\n"
   "      if (oldcmp != k_no_compression) {\n"
   "         MY(ostr)->rdbuf(m_ostr.rdbuf());\n"
   "         delete MY(xcmp);\n"
   "         MY(xcmp) = 0;\n"
   "      }\n"
   "      if (newcmp == k_z_compression) {\n"
   "         //std::cerr << \"output switched on z compression\" << std::endl;\n"
   "         MY(xcmp) = new xstream::z::ostreambuf(m_ostr.rdbuf());\n"
   "         MY(ostr)->rdbuf(MY(xcmp));\n"
   "      }\n"
   "      else if (newcmp == k_bz2_compression) {\n"
   "         //std::cerr << \"output switched on bz2 compression\" << std::endl;\n"
   "         MY(xcmp )= new xstream::bz::ostreambuf(m_ostr.rdbuf());\n"
   "         MY(ostr)->rdbuf(MY(xcmp));\n"
   "      }\n"
   "      else if (newcmp != k_no_compression) {\n"
   "         throw std::runtime_error(\"hddm_r::ostream::configure_streambufs error - \"\n"
   "                                  \"unrecognized compression flag requested.\");\n"
   "      }\n"
   "   }\n"
   "   MY(status_bits) = m_status_bits;\n"
   "}\n"
   "\n"
   "void ostream::lock_streambufs() {\n"
   "   MY_SETUP\n"
   "   if (MY(mutex_lock) != 0) {\n"
   "      unlock_streambufs();\n"
   "      throw std::runtime_error(\"hddm_r::ostream::lock_streambufs error - \"\n"
   "                               \"mutex lock requested when lock already held.\");\n"
   "   }\n"
   "   if ((MY(status_bits) & k_bits_compression) == k_no_compression) {\n"
   "      pthread_mutex_lock(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 1;\n"
   "   }\n"
   "   else if ((MY(status_bits) & k_bits_compression) == k_z_compression) {\n"
   "      ((xstream::z::ostreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 2;\n"
   "   }\n"
   "   else if ((MY(status_bits) & k_bits_compression) == k_bz2_compression) {\n"
   "      ((xstream::bz::ostreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 3;\n"
   "   }\n"
   "   else {\n"
   "      MY(mutex_lock) = -1;\n"
   "   }\n"
   "}\n"
   "\n"
   "void ostream::unlock_streambufs() {\n"
   "   MY_SETUP\n"
   "   if (MY(mutex_lock) == 0) {\n"
   "      throw std::runtime_error(\"hddm_r::ostream::unlock_streambufs error - \"\n"
   "                               \"mutex unlock requested when lock not held.\");\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 1) {\n"
   "      pthread_mutex_unlock(&m_streambuf_mutex);\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 2) {\n"
   "      ((xstream::z::ostreambuf*)MY(xcmp))->set_streambuf_mutex(0);\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 3) {\n"
   "      ((xstream::bz::ostreambuf*)MY(xcmp))->set_streambuf_mutex(0);\n"
   "   }\n"
   "   MY(mutex_lock) = 0;\n"
   "}\n"
   "\n"
   "int istream::getTag(const std::string &src, int start,\n"
   "                    std::string &tag, int &level)\n"
   "{\n"
   "   tag = \"\";\n"
   "   size_t p_btag = src.find(\"<\",start);\n"
   "   size_t p_bline = src.find_last_of(\"\\n\",p_btag);\n"
   "   if (p_bline == std::string::npos)\n"
   "   {\n"
   "      p_bline = 0;\n"
   "   }\n"
   "   else\n"
   "   {\n"
   "      ++p_bline;\n"
   "   }\n"
   "   level = (p_btag-p_bline)/2;\n"
   "   size_t p_etag = p_btag;\n"
   "   for (size_t quotes=0; p_etag < src.size(); ++p_etag) {\n"
   "      if (src[p_etag] == '\"') {\n"
   "         tag += \"\\\"\";\n"
   "         ++quotes;\n"
   "      }\n"
   "      else if (quotes/2*2 != quotes) {\n"
   "         tag += src[p_etag];\n"
   "      }\n"
   "      else if (src.find_first_of(\" \\t\\n\",p_etag) == 0) {\n"
   "         tag += \" \";\n"
   "         p_etag = src.find_first_not_of(\" \\t\\n\",p_etag)-1;\n"
   "      }\n"
   "      else if (src[p_etag] == '>') {\n"
   "         tag += \">\";\n"
   "         break;\n"
   "      }\n"
   "      else {\n"
   "         tag += src[p_etag];\n"
   "      }\n"
   "   }\n"
   "   if (p_etag == src.size()) {\n"
   "      std::stringstream sstr;\n"
   "      sstr << \"hddm_" + classPrefix + "::istream::getTag\"\n"
   "           << \" error - bad header format\" << std::endl\n"
   "           << \"   tag \" << tag << \" at position \" << start\n"
   "           << std::endl;\n"
   "      throw std::runtime_error(sstr.str());\n"
   "   }\n"
   "   return p_etag+2;\n"
   "}\n"
   "\n"
   "int istream::getEndTag(const std::string &src, int start,\n"
   "                       const std::string &tag)\n"
   "{\n"
   "   if (tag.rfind(\"/>\") == tag.size()-2) {\n"
   "      return src.find(tag,start) + tag.size()+1;\n"
   "   }\n"
   "   else {\n"
   "      std::string etag = \"</\";\n"
   "      etag += tag.substr(1,tag.find_first_of(' ')-1) + \">\";\n"
   "      size_t p_etag = src.find(etag,start);\n"
   "      size_t p_quote = src.find_first_of('\"',start);\n"
   "      while (p_quote != std::string::npos && p_quote < p_etag) {\n"
   "         p_quote = src.find_first_of('\"',p_quote+1);\n"
   "         if (p_quote > p_etag) {\n"
   "            p_etag = src.find(etag,p_quote+1);\n"
   "         }\n"
   "         p_quote = src.find_first_of('\"',p_quote+1);\n"
   "      }\n"
   "      if (p_etag == std::string::npos) {\n"
   "         std::stringstream sstr;\n"
   "         sstr << \"hddm_" + classPrefix + "::istream::getEndTag\"\n"
   "              << \" error - bad header format\" << std::endl\n"
   "              << \"   tag \" << tag << \" at position \" << start\n"
   "              << std::endl\n"
   "              << \"   end tag \" << etag << \" not found.\"\n"
   "              << std::endl;\n"
   "         throw std::runtime_error(sstr.str());\n"
   "      }\n"
   "      return p_etag + etag.size()+1;\n"
   "   }\n"
   "}\n"
   "\n"
   "void istream::collide(const std::string &itag, const std::string &rtag) {\n"
   "   std::string itagname = itag.substr(1,itag.find(\" \")-1);\n"
   "   std::string rtagname = rtag.substr(1,rtag.find(\" \")-1);\n"
   "   std::string errmsg = \"hddm_" + classPrefix +
   "::istream::collide warning:\\n\"\n"
   "         \"tag \" + itagname + \" in input file \"\n"
   "         \"does not match c++ header hddm_" << classPrefix << ".hpp\\n\"\n"
   "         \"  input file: \" + itag + \"\\n\"\n"
   "         \"  c++ header: \" + rtag + \"\\n\"\n"
   "         \"  === Tag \" + itagname + \" will be ignored,\"\n"
   "         \" rebuild to cure the problem ===\";\n"
   "   if (itagname != \"HDDM\") {\n"
   "      std::cerr << errmsg << std::endl;\n"
   "   }\n"
   "   else {\n"
   "      throw std::runtime_error(errmsg);\n"
   "   }\n"
   "}\n"
   "\n"
   "chromosome istream::synthesize(const std::string &src, int p_src,\n"
   "                               const std::string &ref, int p_ref)\n"
   "{\n"
   "   chromosome chrom;\n"
   "   int slevel, rlevel;\n"
   "   std::string stag, rtag;\n"
   "   p_src = getTag(src,p_src,stag,slevel);\n"
   "   p_ref = getTag(ref,p_ref,rtag,rlevel);\n"
   "   std::string stagname = stag.substr(1,stag.find(\" \")-1);\n"
   "   std::string rtagname = rtag.substr(1,rtag.find(\" \")-1);\n"
   "   if (stagname != rtagname) {\n"
   "      throw std::runtime_error(\"hddm_" + classPrefix +
   "::istream::synthesize error - matching algorithm error #2\");\n"
   "   }\n"
   "   else if (!tags_match(stag,rtag)) {\n"
   "      collide(stag,rtag);\n"
   "      return chrom;\n"
   "   }\n"
   "\n"
   "   int p2_src, p2_ref;\n"
   "   int s2level, r2level;\n"
   "   std::string s2tag, r2tag;\n"
   "   getTag(src,p2_src=p_src,s2tag,s2level);\n"
   "   while (s2level > slevel) {\n"
   "      codon *gene = new codon();\n"
   "      std::string s2tagname = s2tag.substr(1,s2tag.find(\" \")-1);\n"
   "      getTag(ref,p2_ref=p_ref,r2tag,r2level);\n"
   "      int order_of_this_tag_in_ref = 1;\n"
   "      while (r2level == s2level) {\n"
   "         std::string r2tagname = r2tag.substr(1,r2tag.find(\" \")-1);\n"
   "         if (s2tagname == r2tagname) {\n"
   "            if (!tags_match(s2tag,r2tag)) {\n"
   "               collide(s2tag,r2tag);\n"
   "               break;\n"
   "            }\n"
   "            else {\n"
   "               gene->m_order = order_of_this_tag_in_ref;\n"
   "            }\n"
   "            gene->m_sequence = synthesize(src,p2_src,ref,p2_ref);\n"
   "            break;\n"
   "         }\n"
   "         p2_ref = getEndTag(ref,p2_ref,r2tag);\n"
   "         getTag(ref,p2_ref,r2tag,r2level);\n"
   "         ++order_of_this_tag_in_ref;\n"
   "      }\n"
   "      gene->m_tagname = s2tagname;\n"
   "      chrom.push_back(*gene);\n"
   "      delete gene;\n"
   "      p2_src = getEndTag(src,p2_src,s2tag);\n"
   "      getTag(src,p2_src,s2tag,s2level);\n"
   "   }\n"
   "   return chrom;\n"
   "}\n"
   ;

   XMLPlatformUtils::Terminate();
   return 0;
}

XtString XtString::plural()
{
   XtString p(*this);
   XtString::size_type len = p.size();
   if (len > 3 && p.substr(len-3,3) == "tum")
   {
      p.replace(len-3,3,"ta");
   }
   else if (len > 1 && p.substr(len-3,3) == "ies")
   {
      p.replace(len-3,3,"iesList");
   }
   else if (len > 2 && p.substr(len-2,2) == "ex")
   {
      p.replace(len-2,2,"ices");
   }
   else if (len > 2 && p.substr(len-2,2) == "sh")
   {
      p.replace(len-2,2,"shes");
   }
   else if (len > 1 && p.substr(len-1,1) == "s")
   {
      p.replace(len-1,1,"ses");
   }
   else if (len > 1)
   {
      p += "s";
   }
   return p;
}

/* Map from tag name to name of the corresponding class
 * for the case of simple tags (those that do not repeat)
 */
XtString XtString::simpleType()
{
   XtString p(*this);
   p[0] = toupper(p[0]);
   return p;
}

/* Map from tag name to name of the corresponding class
 * for the case of list tags (those that may repeat)
 */
XtString XtString::listType()
{
   XtString r(*this);
   r[0] = toupper(r[0]);
   r = r + "List";
   return r;
}

/* Map from tag name to name of the corresponding class
 * for the case of link tags (those that do not repeat)
 */
XtString XtString::linkType()
{
   XtString r(*this);
   r[0] = toupper(r[0]);
   r = r + "Link";
   return r;
}

/* Look for a named element in a list of element pointers
 * and return index of first instance in the list if found,
 * otherwise return -1;
 */
int CodeBuilder::element_in_list(XtString &name, parentList_t list)
{
   int n=0;
   parentList_t::iterator iter;
   for (iter = list.begin(); iter != list.end(); ++iter, ++n)
   {
      DOMElement *el = (DOMElement*)(*iter);
      XtString cnameS(el->getTagName());
      if (cnameS == name) {
         return n;
      }
   }
   return -1;
}

/* Verify that the tag group under this element does not collide
 * with existing tag group elref, otherwise exit with fatal error
 */
void CodeBuilder::checkConsistency(DOMElement* el, DOMElement* elref)
{
   XtString tagS(el->getTagName());
   if (el->getParentNode() == elref->getParentNode())
   {
      std::cerr
           << "hddm-cpp error: tag " << "\"" << tagS 
           << "\" is duplicated within one context in xml document."
	   << std::endl;
      exit(1);
   }

   DOMNamedNodeMap* oldAttr = elref->getAttributes();
   DOMNamedNodeMap* newAttr = el->getAttributes();
   unsigned int listLength = oldAttr->getLength();
   for (unsigned int n = 0; n < listLength; n++)
   {
      XtString nameS(oldAttr->item(n)->getNodeName());
      XtString oldS(elref->getAttribute(X(nameS)));
      XtString newS(el->getAttribute(X(nameS)));
      if (nameS == "minOccurs")
      {
         continue;
      }
      else if (nameS == "maxOccurs")
      {
         int maxold = (oldS == "unbounded")? INT_MAX : atoi(S(oldS));
         int maxnew = (newS == "unbounded")? INT_MAX : atoi(S(newS));
	 if ((maxold < 2 && maxnew > 1) || (maxold > 1 && maxnew < 2))
         {
            std::cerr
                 << "hddm-cpp error: inconsistent maxOccurs usage by tag "
                 << "\"" << tagS << "\" in xml document." << std::endl;
            exit(1);
         }
      }
      else if (newS != oldS)
      {
         std::cerr
              << "hddm-cpp error: inconsistent usage of attribute "
              << "\"" << nameS << "\" in tag "
              << "\"" << tagS << "\" in xml document." << std::endl;
         exit(1);
      }
   }
   listLength = newAttr->getLength();
   for (unsigned int n = 0; n < listLength; n++)
   {
      XtString nameS(newAttr->item(n)->getNodeName());
      XtString oldS(elref->getAttribute(X(nameS)));
      XtString newS(el->getAttribute(X(nameS)));
      if (nameS == "minOccurs")
      {
         continue;
      }
      else if (nameS == "maxOccurs")
      {
         int maxold = (oldS == "unbounded")? INT_MAX : atoi(S(oldS));
         int maxnew = (newS == "unbounded")? INT_MAX : atoi(S(newS));
	 if ((maxold < 2 && maxnew > 1) || (maxold > 1 && maxnew < 2))
         {
            std::cerr
                 << "hddm-cpp error: inconsistent maxOccurs usage by tag "
                 << "\"" << tagS << "\" in xml document." << std::endl;
            exit(1);
         }
      }
      else if (newS != oldS)
      {
         std::cerr
              << "hddm-cpp error: inconsistent usage of attribute "
              << "\"" << nameS << "\" in tag "
              << "\"" << tagS << "\" in xml document." << std::endl;
         exit(1);
      }
   }
   DOMNodeList* oldList = elref->getChildNodes();
   DOMNodeList* newList = el->getChildNodes();
   listLength = oldList->getLength();
   if (newList->getLength() != listLength)
   {
      std::cerr
           << "hddm-cpp error: inconsistent usage of tag "
           << "\"" << tagS << "\" in xml document." << std::endl;
   exit(1);
   }
   for (unsigned int n = 0; n < listLength; n++)
   {
      DOMNode* cont = oldList->item(n);
      XtString nameS(cont->getNodeName());
      short type = cont->getNodeType();
      if (type == DOMNode::ELEMENT_NODE)
      {
         DOMNodeList* contList = el->getElementsByTagName(X(nameS));
         if (contList->getLength() != 1)
         {
             std::cerr
                  << "hddm-cpp error: inconsistent usage of tag "
                  << "\"" << tagS << "\" in xml document." << std::endl;
             exit(1);
         }
      }
   }
}

/* Write declaration of the classes for this tag to the header file */

void CodeBuilder::writeClassdef(DOMElement* el)
{
   XtString tagS(el->getTagName());
   hFile << "class " << tagS.simpleType()
         << ": public HDDM_Element {" << std::endl
         << " public:" << std::endl;
   if (tagS == "HDDM") {
      hFile << "   HDDM();" << std::endl;
   }
   hFile << "   ~" << tagS.simpleType() << "();" << std::endl;

   std::map<XtString,XtString> attrList;
   DOMNamedNodeMap *myAttr = el->getAttributes();
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      attrList[attrS] = typeS;
   }
   parentList_t::iterator iter;
   for (iter = parents[tagS].begin(); iter != parents[tagS].end(); ++iter)
   {
      DOMElement *hostEl = (DOMElement*)(*iter);
      XtString hostS(hostEl->getTagName());
      DOMNamedNodeMap *hostAttr = hostEl->getAttributes();
      for (unsigned int n = 0; n < hostAttr->getLength(); n++)
      {
         XtString attrS(hostAttr->item(n)->getNodeName());
         if (attrList.find(attrS) != attrList.end())
         {
            continue;
         }
         XtString typeS(hostEl->getAttribute(X(attrS)));
         attrList[attrS] = typeS;
         XtString getS("get"+attrS.simpleType());
         if (typeS == "int")
         {
            hFile << "   int " << getS << "() const;" << std::endl;
         }
         else if (typeS == "long")
         {
            hFile << "   int64_t " << getS << "() const;" << std::endl;
         }
         else if (typeS == "float")
         {
            hFile << "   float " << getS << "() const;" << std::endl;
         }
         else if (typeS == "double")
         {
            hFile << "   double " << getS << "() const;" << std::endl;
         }
         else if (typeS == "boolean")
         {
            hFile << "   bool " << getS << "() const;" << std::endl;
         }
         else if (typeS == "string")
         {
            hFile << "   std::string " << getS << "() const;" << std::endl;
         }
         else if (typeS == "anyURI")
         {
            hFile << "   std::string " << getS << "() const;" << std::endl;
         }
         else if (typeS == "Particle_t")
         {
            hFile << "   Particle_t " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "int")
         {
            hFile << "   int " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "long")
         {
            hFile << "   int64_t " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "float")
         {
            hFile << "   float " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "double")
         {
            hFile << "   double " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "boolean")
         {
            hFile << "   bool " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "Particle_t")
         {
            hFile << "   Particle_t " << getS << "() const;" << std::endl;
         }
         else /* any values not matching the above are strings */
         {
            hFile << "   std::string " << getS << "() const;" << std::endl;
         }
      }
   }

   myAttr = el->getAttributes();
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      XtString getS("get" + attrS.simpleType());
      XtString setS("set" + attrS.simpleType());
      if (typeS == "int")
      {
         hFile << "   int " << getS << "() const;" << std::endl
               << "   void " << setS << "(int " << attrS << ");" << std::endl;
      }
      else if (typeS == "long")
      {
         hFile << "   int64_t " << getS << "() const;" << std::endl
               << "   void " << setS << "(int64_t " << attrS << ");" << std::endl;
      }
      else if (typeS == "float")
      {
         hFile << "   float " << getS << "() const;" << std::endl
               << "   void " << setS << "(float " << attrS << ");" << std::endl;
      }
      else if (typeS == "double")
      {
         hFile << "   double " << getS << "() const;" << std::endl
               << "   void " << setS << "(double " << attrS << ");" << std::endl;
      }
      else if (typeS == "boolean")
      {
         hFile << "   bool " << getS << "() const;" << std::endl
               << "   void " << setS << "(bool " << attrS << ");" << std::endl;
      }
      else if (typeS == "string")
      {
         hFile << "   std::string " << getS << "() const;" << std::endl
               << "   void " << setS << "(const std::string &" << attrS << ");"
               << std::endl;
      }
      else if (typeS == "anyURI")
      {
         hFile << "   std::string " << getS << "() const;" << std::endl
               << "   void " << setS << "(const std::string &" << attrS << ");"
               << std::endl;
      }
      else if (typeS == "Particle_t")
      {
         hFile << "   Particle_t " << getS << "() const;" << std::endl
               << "   void " << setS << "(Particle_t " << attrS << ");" << std::endl;
      }
      else if (guessType(typeS) == "int")
      {
         hFile << "   int " << getS << "() const;" << std::endl;
      }
      else if (guessType(typeS) == "long")
      {
         hFile << "   int64_t " << getS << "() const;" << std::endl;
      }
      else if (guessType(typeS) == "float")
      {
         hFile << "   float " << getS << "() const;" << std::endl;
      }
      else if (guessType(typeS) == "double")
      {
         hFile << "   double " << getS << "() const;" << std::endl;
      }
      else if (guessType(typeS) == "boolean")
      {
         hFile << "   bool " << getS << "() const;" << std::endl;
      }
      else if (guessType(typeS) == "Particle_t")
      {
         hFile << "   Particle_t " << getS << "() const;" << std::endl;
      }
      else /* any attributes not matching the above are strings */
      {
         hFile << "   std::string " << getS << "() const;" << std::endl;
      }
   }

   if (tagS == "HDDM") {
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString cnameS(piter->first);
         if (cnameS != "HDDM" && element_in_list(cnameS,children[tagS]) == -1)
         {
            hFile << "   " << cnameS.listType() << " get"
                  << cnameS.plural().simpleType() << "();" << std::endl;
         }
      }
   }

   parentList_t::iterator citer;
   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      hFile << "   " << cnameS.simpleType() << " &get"
            << cnameS.simpleType()
            << ((rep > 1)? "(int index=0);" : "();") << std::endl;
      hFile << "   " << cnameS.listType() << " &get" 
            << cnameS.plural().simpleType() << "();" << std::endl;
      hFile << "   " << cnameS.listType() << " add"
            << cnameS.plural().simpleType()
            << "(int count=1, int start=-1);" << std::endl;
      hFile << "   void delete"
            << cnameS.plural().simpleType()
            << "(int count=-1, int start=0);" << std::endl;
   }

   hFile << "   const void *getAttribute(const std::string &name,"
         << " hddm_type *atype=0) const;\n"
         << "   std::string toString(int indent=0);\n"
         << "   std::string toXML(int indent=0);\n";

   if (tagS == "HDDM")
   {
      hFile << "   void clear();" << std::endl;
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString cnameS(piter->first);
         if (cnameS != "HDDM") {
            hFile << "   friend class " << cnameS.simpleType() << ";"
                  << std::endl;
         }
      }
      hFile << "   static std::string DocumentString();" << std::endl;
      hFile << " private:" << std::endl;
   }
   else
   {
      hFile << "   friend class HDDM_ElementList<"
            << tagS.simpleType() << ">;" << std::endl
            << "   friend class HDDM_ElementLink<"
            << tagS.simpleType() << ">;" << std::endl;
      hFile << " private:" << std::endl
            << "   " << tagS.simpleType()
            << "(HDDM_Element *parent=0);" << std::endl;
   }

   hFile << "   void streamer(istream &istr);" << std::endl
         << "   void streamer(ostream &ostr);" << std::endl;

   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (typeS == "int")
      {
         hFile << "   int m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "long")
      {
         hFile << "   int64_t m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "float")
      {
         hFile << "   float m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "double")
      {
         hFile << "   double m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "boolean")
      {
         hFile << "   int m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "string")
      {
         hFile << "   std::string m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "anyURI")
      {
         hFile << "   std::string m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "Particle_t")
      {
         hFile << "   int m_" << attrS << ";" << std::endl;
      }
   }

   if (tagS == "HDDM") {
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString dnameS(piter->first);
         if (dnameS != "HDDM") {
            hFile << "   std::list<" << dnameS.simpleType()
                  << "*> m_" << dnameS << "_plist;" << std::endl;
         }
      }
   }

   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      hFile << "   " << ((rep > 1)? cnameS.listType() : cnameS.linkType())
            << " m_" << cnameS
            << ((rep > 1)? "_list;" : "_link;") << std::endl;
   }

   hFile << "};" << std::endl << std::endl;

   if (tagS != "HDDM")
   {
      hFile << "typedef HDDM_ElementList<"
            << tagS.simpleType() << "> "
            << tagS.listType() << ";" << std::endl
            << "typedef HDDM_ElementLink<"
            << tagS.simpleType() << "> "
            << tagS.linkType() << ";"
            << std::endl << std::endl;
   }
}

/* Generate class declarations for this tag and its descendants;
 * this function calls itself recursively
 */

void CodeBuilder::constructGroup(DOMElement* el)
{
   XtString tagS(el->getTagName());
   parentList_t::iterator piter;
   parents[tagS].insert(parents[tagS].begin(),
                        parentList.begin(),parentList.end());
   std::vector<DOMElement*>::iterator iter;
   for (iter = tagList.begin(); iter != tagList.end(); iter++)
   {
      DOMElement* targEl = *iter;
      XtString targS(targEl->getTagName());
      if (tagS == targS)
      {
         checkConsistency(el,targEl);
         return;
      }
   }

   parentList.push_back(el);
   DOMNodeList* contList = el->getChildNodes();
   int contLength = contList->getLength();
   for (int c = 0; c < contLength; c++)
   {
      DOMNode* cont = contList->item(c);
      short type = cont->getNodeType();
      if (type == DOMNode::ELEMENT_NODE)
      {
         DOMElement* contEl = (DOMElement*) cont;
         XtString contS(contEl->getTagName());
         children[tagS].push_back(contEl);
         constructGroup(contEl);
      }
   }
   parentList.pop_back();

   tagList.push_back(el);

   if (tagS == "HDDM")
   {
      std::vector<DOMElement*>::iterator iter;
      for (iter = tagList.begin(); iter != tagList.end(); iter++)
      {
         writeClassdef(*iter);
      }
   }
}

/* Write method implementation of the classes for this tag to the header file */

void CodeBuilder::writeClassimp(DOMElement* el)
{
   XtString tagS(el->getTagName());
   if (tagS == "HDDM")
   {
      hFile << "inline " << tagS.simpleType() << "::"
            << tagS.simpleType() << "()" << std::endl
            << " : HDDM_Element()";
   }
   else
   {
      hFile << "inline " << tagS.simpleType() << "::"
            << tagS.simpleType() << "(HDDM_Element *parent)" << std::endl
            << " : HDDM_Element(parent)";
   }
   DOMNamedNodeMap *myAttr = el->getAttributes();
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (typeS == "int")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else if (typeS == "long")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else if (typeS == "float")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else if (typeS == "double")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else if (typeS == "boolean")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else if (typeS == "string")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(\"\")";
      }
      else if (typeS == "anyURI")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(\"\")";
      }
      else if (typeS == "Particle_t")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else
      {
         /* ignore attributes with unrecognized values */
      }
   }
	
	// Write XXX_plist initializers first and then the XXX_list or
	// XXX_link initializers. This is because the plist members
	// appear first in the class definition.
	// Dec. 3, 2012  David L.
   parentList_t::iterator citer;
   for (citer = children[tagS].begin();
        citer != children[tagS].end();
        ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      // int rep;  commented out to avoid compiler warnings 4/26/2015 DL
      // rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      XtString hostS("m_host->");
      if (tagS == "HDDM")
      {
         hFile << "," << std::endl << "   m_" << cnameS
               << "_plist()";
         hostS = "";
      }
   }
   for (citer = children[tagS].begin();
        citer != children[tagS].end();
        ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      const char *myHost = (tagS=="HDDM" ? "this->":"m_host->");
      XtString hostS(myHost);
      hFile << "," << std::endl << "   m_" << cnameS
            << ((rep > 1)? "_list" : "_link")
            << "(&" << hostS << "m_" << cnameS << "_plist," << std::endl
            << "               "
            << hostS << "m_" << cnameS << "_plist.end()," << std::endl
            << "               "
            << hostS << "m_" << cnameS << "_plist.end()," << std::endl
            << "               "
            << "this)";
   }
   if (tagS == "HDDM")
   {
      hFile << std::endl << "{" << std::endl
            << "   m_host = this;" << std::endl
            << "}" << std::endl << std::endl;
   }
   else
   {
      hFile << std::endl << "{}" << std::endl << std::endl;
   }

   hFile << "inline " << tagS.simpleType() << "::~"
         << tagS.simpleType() << "() {"
         << ((children[tagS].size())? "\n" : "");
   for (citer = children[tagS].begin();
        citer != children[tagS].end();
        ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      hFile << "   delete" << cnameS.plural().simpleType()
            << "();" << std::endl;
   }
   hFile << "}" << std::endl << std::endl;

   std::map<XtString,XtString> attrList;
   myAttr = el->getAttributes();
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      attrList[attrS] = typeS;
   }
   parentList_t::iterator iter;
   for (iter = parents[tagS].begin(); iter != parents[tagS].end(); ++iter)
   {
      DOMElement *hostEl = (DOMElement*)(*iter);
      DOMNamedNodeMap *hostAttr = hostEl->getAttributes();
      for (unsigned int n = 0; n < hostAttr->getLength(); n++)
      {
         XtString attrS(hostAttr->item(n)->getNodeName());
         if (attrList.find(attrS) != attrList.end())
         {
            continue;
         }
         XtString typeS(hostEl->getAttribute(X(attrS)));
         attrList[attrS] = typeS;
         XtString getS("get" + attrS.simpleType());
         if (typeS == "int")
         {
            hFile << "inline int " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(int*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "long")
         {
            hFile << "inline int64_t " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(int64_t*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "float")
         {
            hFile << "inline float " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(float*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "double")
         {
            hFile << "inline double " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(double*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "boolean")
         {
            hFile << "inline bool " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(bool*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "string")
         {
            hFile << "inline std::string " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(const std::string*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "anyURI")
         {
            hFile << "inline std::string " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(const std::string*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "Particle_t")
         {
            hFile << "inline Particle_t " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(Particle_t*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "int")
         {
            hFile << "inline int " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(int*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "long")
         {
            hFile << "inline int64_t " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(long long int*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "float")
         {
            hFile << "inline float " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(float*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "double")
         {
            hFile << "inline double " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(double*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "boolean")
         {
            hFile << "inline bool " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(bool*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "Particle_t")
         {
            hFile << "inline Particle_t " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(Particle_t*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else /* any attributes not of the above types are strings */
         {
            hFile << "inline std::string " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(std::string*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
      }
   }

   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      XtString getS("get" + attrS.simpleType());
      XtString setS("set" + attrS.simpleType());
      if (typeS == "int")
      {
         hFile << "inline int " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(int " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "long")
      {
         hFile << "inline int64_t " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(int64_t " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "float")
      {
         hFile << "inline float " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(float " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "double")
      {
         hFile << "inline double " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(double " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "boolean")
      {
         hFile << "inline bool " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(bool " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "string")
      {
         hFile << "inline std::string " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(const std::string &" << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "anyURI")
      {
         hFile << "inline std::string " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(const std::string &" << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "Particle_t")
      {
         hFile << "inline Particle_t " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return (Particle_t)m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(Particle_t " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "int")
      {
         hFile << "inline int " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return " << typeS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "long")
      {
         hFile << "inline int64_t " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return " << typeS << "LL;" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "float")
      {
         hFile << "inline float " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return " << typeS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "double")
      {
         hFile << "inline double " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return " << typeS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "boolean")
      {
         hFile << "inline bool " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return " << typeS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "Particle_t")
      {
         hFile << "inline Particle_t " << tagS.simpleType()
               << "::" << getS << "() const {" << std::endl
               << "   return (Particle_t)" << lookupParticle(typeS)
               << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else /* anything not listed above is classed as a string */
      {
         hFile << "inline std::string " << tagS.simpleType()
               << "::" << getS << "() const {" << std::endl
               << "   return \"" << typeS << "\";" << std::endl
               << "}" << std::endl << std::endl;
      }
   }

   if (tagS == "HDDM")
   {
      hFile << "inline void HDDM::clear() {" << std::endl;
      for (citer = children[tagS].begin();
           citer != children[tagS].end();
           ++citer)
      {
         DOMElement *childEl = (DOMElement*)(*citer);
         XtString cnameS(childEl->getTagName());
         hFile << "   delete" << cnameS.simpleType().plural()
               << "();" << std::endl;
      }
      hFile << "}" << std::endl << std::endl;
   }
   hFile << "inline const void *" << tagS.simpleType()
         << "::getAttribute(const std::string &name,\n"
         << "                                                   "
         << "hddm_type *atype) const {" << std::endl;
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      hFile << "   if (name == \"" << attrS << "\") {\n"
            << "      if (atype != 0)\n";
      if (typeS == "int")
      {
         hFile << "         *atype = k_hddm_int;\n";
      }
      else if (typeS == "long")
      {
         hFile << "         *atype = k_hddm_long;\n";
      }
      else if (typeS == "float")
      {
         hFile << "         *atype = k_hddm_float;\n";
      }
      else if (typeS == "double")
      {
         hFile << "         *atype = k_hddm_double;\n";
      }
      else if (typeS == "boolean")
      {
         hFile << "         *atype = k_hddm_boolean;\n";
      }
      else if (typeS == "string")
      {
         hFile << "         *atype = k_hddm_string;\n";
      }
      else if (typeS == "anyURI")
      {
         hFile << "         *atype = k_hddm_anyURI;\n";
      }
      else if (typeS == "Particle_t")
      {
         hFile << "         *atype = k_hddm_Particle_t;\n";
      }
      else if (guessType(typeS) == "int")
      {
         hFile << "         *atype = k_hddm_int;\n"
               << "      static int m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else if (guessType(typeS) == "long")
      {
         hFile << "         *atype = k_hddm_long;\n"
               << "      static long m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else if (guessType(typeS) == "float")
      {
         hFile << "         *atype = k_hddm_float;\n"
               << "      static float m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else if (guessType(typeS) == "double")
      {
         hFile << "         *atype = k_hddm_double;\n"
               << "      static double m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else if (guessType(typeS) == "boolean")
      {
         hFile << "         *atype = k_hddm_boolean;\n"
               << "      static int m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else if (guessType(typeS) == "Particle_t")
      {
         hFile << "         *atype = k_hddm_Particle_t;\n"
               << "      static Particle_t m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else
      {
         hFile << "         *atype = k_hddm_unknown;\n"
               << "      static std::string m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      hFile << "      return &m_" << attrS << ";\n"
            << "   }\n";
   }
   if (tagS != "HDDM")
   {
      hFile << "   return m_parent->getAttribute(name, atype);" << std::endl;
   }
   else
   {
      hFile << "   return 0;" << std::endl;
   }
   hFile << "}" << std::endl << std::endl;

   hFile << "inline std::string " << tagS.simpleType()
         << "::toString(int indent) {\n"
         << "   std::stringstream ostr;\n"
         << "   for (int n=0; n < indent; ++n)\n"
         << "      ostr << \" \";\n"
         << "   ostr << \"" << tagS << "\"\n";
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (typeS == "int" || typeS == "long" || 
          typeS == "float" || typeS == "double")
      {
	     hFile << "        << \" " << attrS << "=\" << "
               << "m_" << attrS << std::endl;
      }
      else if (typeS == "boolean")
      {
	     hFile << "        << \" " << attrS << "=\" << "
               << "((m_" << attrS << " == 0)? \"true\" : \"false\")"
               << std::endl;
      }
      else if (typeS == "string" || typeS == "anyURI")
      {
	     hFile << "        << \" " << attrS << "=\" << "
               << "\"\\\"\" << m_" << attrS << " << \"\\\"\"" << std::endl;
      }
      else if (typeS == "Particle_t")
      {
	     hFile << "        << \" " << attrS << "=\" << "
               << "ParticleType((Particle_t)m_" << attrS << ")" << std::endl;
      }
   }
   hFile << "             << std::endl;" << std::endl;
   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      if (rep > 1)
      {
         hFile << "   for (" << cnameS.listType() << "::iterator it = "
               << "m_" << cnameS << "_list.begin();" << std::endl
               << "        it != "
               << "m_" << cnameS << "_list.end(); ++it)" << std::endl
               << "   {" << std::endl
               << "      ostr << it->toString(indent + 2);" << std::endl
               << "   }" << std::endl;
      }
      else
      {
         hFile << "   if (! m_" << cnameS << "_link.empty()) {\n"
               << "      ostr << m_" << cnameS << "_link.begin()"
               << "->toString(indent + 2);\n"
               << "   }" << std::endl;
      }
   }
   hFile << "   return ostr.str();" << std::endl
         << "}" << std::endl << std::endl;

   hFile << "inline std::string " << tagS.simpleType()
         << "::toXML(int indent) {\n"
         << "   std::stringstream ostr;\n"
         << "   for (int n=0; n < indent; ++n)\n"
         << "      ostr << \" \";\n"
         << "   ostr << \"<" << tagS << "\"\n";
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (attrS == "minOccurs" || attrS == "maxOccurs")
      {
         continue;
      }
      if (typeS == "boolean")
      {
	     hFile << "        << \" " << attrS << "=\" << "
               << "((m_" << attrS << " == 0)? \"\\\"true\\\"\" : \"\\\"false\\\"\")"
               << std::endl;
      }
      else if (typeS == "Particle_t")
      {
	     hFile << "        << \" " << attrS << "=\\\"\" << "
               << "ParticleType((Particle_t)m_" << attrS << ") << \"\\\"\""
               << std::endl;
      }
      else
      {
	     hFile << "        << \" " << attrS << "=\" << "
               << "\"\\\"\" << get" << attrS.simpleType() 
               << "() << \"\\\"\"" << std::endl;
      }
   }
   if (children[tagS].size() > 0)
   {
       hFile << "        << \">\" << std::endl;" << std::endl;
   }
   else
   {
       hFile << "        << \" />\" << std::endl;" << std::endl;
   }
   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      if (rep > 1)
      {
         hFile << "   for (" << cnameS.listType() << "::iterator it = "
               << "m_" << cnameS << "_list.begin();" << std::endl
               << "        it != "
               << "m_" << cnameS << "_list.end(); ++it)" << std::endl
               << "   {" << std::endl
               << "      ostr << it->toXML(indent + 2);" << std::endl
               << "   }" << std::endl;
      }
      else
      {
         hFile << "   if (! m_" << cnameS << "_link.empty()) {\n"
               << "      ostr << m_" << cnameS << "_link.begin()"
               << "->toXML(indent + 2);" << std::endl
               << "   }" << std::endl;
      }
   }
   if (children[tagS].size() > 0)
   {
      hFile << "   for (int n=0; n < indent; ++n)\n"
            << "      ostr << \" \";\n"
            << "   ostr << \"</" << tagS << ">\"\n"
            << "        << std::endl;" << std::endl;
   }
   hFile << "   return ostr.str();" << std::endl
         << "}" << std::endl << std::endl;

   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      if (rep > 1)
      {
         hFile << "inline " << cnameS.simpleType() << " &"
               << tagS.simpleType() << "::get" << cnameS.simpleType()
               << "(int index) {" << std::endl
               << "   return m_" << cnameS << "_list(index);" << std::endl
               << "}" << std::endl << std::endl
               << "inline " << cnameS.listType() << " &" 
               << tagS.simpleType() << "::get" << cnameS.plural().simpleType()
               << "() {" << std::endl
               << "   return m_" << cnameS << "_list;" << std::endl
               << "}" << std::endl << std::endl
               << "inline " << cnameS.listType() << " "
               << tagS.simpleType() << "::add" << cnameS.plural().simpleType()
               << "(int count, int start) {" << std::endl
               << "   return m_" << cnameS << "_list.add(count,start);"
               << std::endl << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::delete"
               << cnameS.simpleType().plural()
               << "(int count, int start) {" << std::endl
               << "   m_" << cnameS << "_list.del(count,start);"
               << std::endl << "}" << std::endl << std::endl;
      }
      else
      {
         hFile << "inline " << cnameS.simpleType() << " &"
               << tagS.simpleType() << "::get" << cnameS.simpleType()
               << "() {" << std::endl
               << "   return m_" << cnameS << "_link.front();" << std::endl
               << "}" << std::endl << std::endl
               << "inline " << cnameS.listType() << " &" 
               << tagS.simpleType() << "::get" << cnameS.plural().simpleType()
               << "() {" << std::endl
               << "   return m_" << cnameS << "_link;" << std::endl
               << "}" << std::endl << std::endl
               << "inline " << cnameS.listType() << " "
               << tagS.simpleType() << "::add" << cnameS.plural().simpleType()
               << "(int count, int start) {" << std::endl
               << "   return m_" << cnameS << "_link.add(count,start);"
               << std::endl << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::delete"
               << cnameS.simpleType().plural()
               << "(int count, int start) {" << std::endl
               << "   m_" << cnameS << "_link.del(count,start);"
               << std::endl << "}" << std::endl << std::endl;
      }
   }

   if (tagS == "HDDM")
   {
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString cnameS(piter->first);
         if (cnameS != "HDDM" && element_in_list(cnameS,children[tagS]) == -1)
         {
            hFile << "inline " << cnameS.listType() << " "
                  << "HDDM::get" << cnameS.plural().simpleType() << "() {"
                  << std::endl << "   return " << cnameS.listType()
                  << "(&m_" << cnameS << "_plist," << std::endl
                  << "                   "
                  << "m_" << cnameS << "_plist.begin()," << std::endl
                  << "                   "
                  << "m_" << cnameS << "_plist.end());" << std::endl
                  << "}" << std::endl << std::endl;
         }
      }
   }
}

/* Generate implementation code for data model classes */

void CodeBuilder::constructMethods(DOMElement* el)
{
   std::vector<DOMElement*>::iterator iter;
   for (iter = tagList.begin(); iter != tagList.end(); iter++)
   {
      writeClassimp(*iter);
   }
}

/* Generate methods for serializing classes to a stream and back again */

void CodeBuilder::writeStreamers(DOMElement* el)
{
   XtString tagS(el->getTagName());

   std::vector<XtString> attrV;
   DOMNamedNodeMap *myAttr = el->getAttributes();
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (typeS == "int" || typeS == "long" || typeS == "float" ||
          typeS == "double" || typeS == "boolean" || typeS == "string" ||
          typeS == "anyURI" || typeS == "Particle_t")
      {
         attrV.push_back(attrS);
      }
   }

   std::vector<XtString> contV;
   DOMNodeList* contList = el->getChildNodes();
   int contListLength = contList->getLength();
   for (int c = 0; c < contListLength; c++)
   {
      DOMNode* node = contList->item(c);
      if (node->getNodeType() == DOMNode::ELEMENT_NODE)
      {
         DOMElement *contEl = (DOMElement*)node;
         XtString contS(contEl->getTagName());
         XtString repS(contEl->getAttribute(X("maxOccurs")));
         int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
         contV.push_back(contS + ((rep > 1)? "_list" : "_link"));
      }
   }

   hFile << "inline void " << tagS.simpleType() << "::streamer"
         << "(istream &istr) {" << std::endl;
   if (attrV.size()) {
      hFile << "   *istr.getXDRistream()";
      for (unsigned int n=0; n < attrV.size(); ++n)
      {
         hFile << " >> m_" << attrV[n];
      }
      hFile << ";" << std::endl;
   }
   if (contV.size()) {
      hFile << "   istr";
      for (unsigned int n=0; n < contV.size(); ++n)
      {
         hFile << " >> m_" << contV[n];
      }
      hFile << ";" << std::endl;
   }
   hFile << "}" << std::endl << std::endl;

   hFile << "inline void " << tagS.simpleType() << "::streamer"
         << "(ostream &ostr) {" << std::endl;
   if (attrV.size()) {
      hFile << "   *ostr.getXDRostream()";
      for (unsigned int n=0; n < attrV.size(); ++n)
      {
         hFile << " << m_" << attrV[n];
      }
      hFile << ";" << std::endl;
   }
   if (contV.size()) {
      hFile << "   ostr";
      for (unsigned int n=0; n < contV.size(); ++n)
      {
         hFile << " << m_" << contV[n];
      }
      hFile << ";" << std::endl;
   }
   hFile << "}" << std::endl << std::endl;
}

void CodeBuilder::constructStreamers(DOMElement* el)
{
   std::vector<DOMElement*>::iterator iter;
   for (iter = tagList.begin(); iter != tagList.end(); ++iter)
   {
      writeStreamers(*iter);
   }
}
 
/* Generate methods to read from binary stream into classes */

void CodeBuilder::constructIOstreams(DOMElement* el)
{
   hFile <<
   "inline istream::thread_private_data *istream::lookup_private_data() {\n"
   "   thread_private_data *my_private = my_thread_private[threads::getID()];\n"
   "   if (my_private != 0)\n"
   "      return my_private;\n"
   "   init_private_data();\n"
   "   return my_thread_private[threads::ID];\n"
   "}\n"
   "\n"
   "inline ostream::thread_private_data *ostream::lookup_private_data() {\n"
   "   thread_private_data *my_private = my_thread_private[threads::getID()];\n"
   "   if (my_private != 0)\n"
   "      return my_private;\n"
   "   init_private_data();\n"
   "   return my_thread_private[threads::ID];\n"
   "}\n"
   "\n"
   "inline void istream::skip(int count) {\n"
   "   MY_SETUP\n"
   "   MY(events_to_skip) = count;\n"
   "}\n"
   "\n"
   "inline bool istream::eof() {\n"
   "   MY_SETUP\n"
   "   return MY(hit_eof);\n"
   "}\n"
   "\n"
   "inline bool istream::operator!() {\n"
   "   return eof();\n"
   "}\n"
   "\n"
   "inline istream::operator void*() {\n"
   "   MY_SETUP\n"
   "   if (MY(hit_eof))\n"
   "      return NULL;\n"
   "   else\n"
   "      return this;\n"
   "}\n"
   "\n"
   "inline int istream::getCompression() const {\n"
   "   return (int)m_status_bits & k_bits_compression;\n"
   "}\n"
   "\n"
   "inline int ostream::getCompression() const {\n"
   "   return (int)m_status_bits & k_bits_compression;\n"
   "}\n"
   "\n"
   "inline int istream::getIntegrityChecks() const {\n"
   "   return (int)m_status_bits & k_bits_integrity;\n"
   "}\n"
   "\n"
   "inline int istream::getBytesRead() const {\n"
   "   int bytes = 0;\n"
   "   for (int i=1; i < threads::max_threads; ++i)\n"
   "      if (my_thread_private[i])\n"
   "         bytes += my_thread_private[i]->m_bytes_read;\n"
   "   return bytes;\n"
   "}\n"
   "\n"
   "inline int istream::getRecordsRead() const {\n"
   "   int records = 0;\n"
   "   for (int i=1; i < threads::max_threads; ++i)\n"
   "      if (my_thread_private[i])\n"
   "         records += my_thread_private[i]->m_records_read;\n"
   "   return records;\n"
   "}\n"
   "\n"
   "inline int ostream::getIntegrityChecks() const {\n"
   "   return (int)m_status_bits & k_bits_integrity;\n"
   "}\n"
   "\n"
   "inline int ostream::getBytesWritten() const {\n"
   "   int bytes = 0;\n"
   "   for (int i=1; i < threads::max_threads; ++i)\n"
   "      if (my_thread_private[i])\n"
   "         bytes += my_thread_private[i]->m_bytes_written;\n"
   "   return bytes;\n"
   "}\n"
   "\n"
   "inline int ostream::getRecordsWritten() const {\n"
   "   int records = 0;\n"
   "   for (int i=1; i < threads::max_threads; ++i)\n"
   "      if (my_thread_private[i])\n"
   "         records += my_thread_private[i]->m_records_written;\n"
   "   return records;\n"
   "}\n"
   "\n"
   "inline istream &istream::operator>>(streamable &object) {\n"
   "   MY_SETUP\n"
   "   if (MY(sequencing)) {\n"
   "      MY(codon)->m_target.push_back(&object);\n"
   "   }\n"
   "   else {\n"
   "      int size;\n"
   "      *MY(xstr) >> size;\n"
   "      if (size > 0) {\n"
   "         std::streampos start = MY(sbuf)->tellg();\n"
   "         sequencer(object);\n"
   "         MY(sbuf)->seekg(start+(std::streamoff)size);\n"
   "      }\n"
   "   }\n"
   "   return *this;\n"
   "}\n"
   "\n"
   "inline void istream::reset_sequencer() {\n"
   "   MY_SETUP\n"
   "   MY(sequencing) = 0;\n"
   "}\n"
   "\n"
   "inline void istream::sequencer(streamable &object) {\n"
   "   MY_SETUP\n"
   "   MY(sequencing) = 1;\n"
   "   MY(codon)->m_target.clear();\n"
   "   object.streamer(*this);\n"
   "   if (MY(sequencing)) {\n"
   "      MY(sequencing) = 0;\n"
   "      codon &gene = *MY(codon);\n"
   "      streamable null_streamable;\n"
   "      gene.m_target.push_front(&null_streamable);\n"
   "      chromosome::iterator iter;\n"
   "      for (iter = gene.m_sequence.begin();\n"
   "           iter != gene.m_sequence.end();\n"
   "           ++iter)\n"
   "      {\n"
   "         MY(codon) = &(*iter);\n"
   "         *this >> *gene.m_target[iter->m_order];\n"
   "      }\n"
   "      MY(codon) = &gene;\n"
   "   }\n"
   "}\n"
   "\n"
   "inline ostream &ostream::operator<<(HDDM &record) {\n"
   "   MY_SETUP\n"
   "   MY(sbuf)->reset();\n"
   "   *this << (streamable&)record;\n"
   "   while (MY(sbuf)->size() == MY(event_buffer_size)) {\n"
   "      delete MY(xstr);\n"
   "      delete MY(sbuf);\n"
   "      char *newbuf = new char[MY(event_buffer_size) *= 2];\n"
   "      MY(sbuf) = new ostreambuffer(newbuf, MY(event_buffer_size));\n"
   "      MY(xstr) = new xstream::xdr::ostream(MY(sbuf));\n"
   "      delete [] MY(event_buffer);\n"
   "      MY(event_buffer) = newbuf;\n"
   "      *this << (streamable&)record;\n"
   "   }\n" 
   "   if ((MY(status_bits) & k_crc32_integrity) != 0) {\n"
   "      xstream::digest::crc32 crc;\n"
   "      std::ostream out(&crc);\n"
   "      out.write(MY(sbuf)->getbuf(),MY(sbuf)->size());\n"
   "      out.flush();\n"
   "      unsigned int crc32 = crc.digest();\n"
   "      *MY(xstr) << crc32;\n"
   "   }\n"
   "   lock_streambufs();\n"
   "   update_streambufs();\n"
   "   MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());\n"
   "   if (!MY(ostr)->good()) {\n"
   "      unlock_streambufs();\n"
   "      throw std::runtime_error(\"hddm_r::ostream::operator<< error - \"\n"
   "                               \"write error on event output!\");\n" 
   "   }\n" 
   "   if (MY(status_bits) & k_bz2_compression) {\n"
   "      MY(last_start) = ((xstream::bz::ostreambuf*)MY(xcmp))->get_block_start();\n"
   "      MY(last_offset) = ((xstream::bz::ostreambuf*)MY(xcmp))->get_block_offset();\n"
   "   }\n"
   "   else if (MY(status_bits) & k_z_compression) {\n"
   "      MY(last_start) = ((xstream::z::ostreambuf*)MY(xcmp))->get_block_start();\n"
   "      MY(last_offset) = ((xstream::z::ostreambuf*)MY(xcmp))->get_block_offset();\n"
   "   }\n"
   "   else {\n"
   "      MY(last_start) = m_ostr.tellp();\n"
   "      MY(last_offset) = 0;\n"
   "   }\n"
   "   unlock_streambufs();\n"
   "   MY(bytes_written) += MY(sbuf)->size();\n"
   "   MY(records_written)++;\n"
   "   return *this;\n"
   "}\n"
   "\n"
   "inline ostream &ostream::operator<<(streamable &object) {\n"
   "   MY_SETUP\n"
   "   *MY(xstr) << 0;\n"
   "   std::streampos start = MY(sbuf)->tellp();\n"
   "   object.streamer(*this);\n"
   "   std::streampos end = MY(sbuf)->tellp();\n"
   "   MY(sbuf)->seekp(start-std::streamoff(4));\n"
   "   *MY(xstr) << (int)(end-start);\n"
   "   MY(sbuf)->seekp(end);\n"
   "   return *this;\n"
   "}\n\n"
   ;
}

/* Generate the xml template in normal form and store in a string */

void CodeBuilder::constructDocument(DOMElement* el)
{
   static int indent = 0;
   hFile << "\"";
   for (int n = 0; n < indent; n++)
   {
      hFile << "  ";
   }
   
   XtString tagS(el->getTagName());
   hFile << "<" << tagS;
   DOMNamedNodeMap* attrList = el->getAttributes();
   int attrListLength = attrList->getLength();
   for (int a = 0; a < attrListLength; a++)
   {
      DOMNode* node = attrList->item(a);
      XtString nameS(node->getNodeName());
      XtString valueS(node->getNodeValue());
      hFile << " " << nameS << "=\\\"" << valueS << "\\\"";
   }

   DOMNodeList* contList = el->getChildNodes();
   int contListLength = contList->getLength();
   if (contListLength > 0)
   {
      hFile << ">\\n\"" << std::endl;
      indent++;
      for (int c = 0; c < contListLength; c++)
      {
         DOMNode* node = contList->item(c);
         if (node->getNodeType() == DOMNode::ELEMENT_NODE)
         {
            DOMElement* contEl = (DOMElement*) node;
            constructDocument(contEl);
         }
      }
      indent--;
      hFile << "\"";
      for (int n = 0; n < indent; n++)
      {
         hFile << "  ";
      }
      hFile << "</" << tagS << ">\\n\"" << std::endl;
   }
   else
   {
      hFile << " />\\n\"" << std::endl;
   }
}

std::string guessType(const std::string &literal)
{
   const char *str = literal.c_str();
   char *endptr;
   errno=0;
   long long int llvalue = strtoll(str,&endptr,0);
   if (errno == 0 && *endptr == 0) {
      errno=0;
      int lvalue = strtol(str,&endptr,0);
      if (errno == 0 && *endptr == 0 && lvalue == llvalue) {
         return "int";
      }
      else {
         return "long";
      }
   }
   errno=0;
   strtof(str,&endptr);
   if (errno == 0 && *endptr == 0) {
      return "float";
   }
   errno=0;
   strtod(str,&endptr);
   if (errno == 0 && *endptr == 0) {
      return "double";
   }
   if (literal == "true" || literal == "false") {
      return "boolean";
   }
   if ((int)lookupParticle(literal) != 0) {
      return "Particle_t";
   }
   if (XMLUri::isValidURI(false,X(literal))) {
      return "anyURI";
   }
   return "string";
}

Particle_t lookupParticle(const std::string &name)
{
   for (int p=0; p<100; ++p) {
      if (ParticleType((Particle_t)p) == name) {
         return (Particle_t)p;
      }
   }
   return Unknown;
}
